[{"title":"C++ primer笔记","url":"/2023/03/05/C++%20primer%E7%AC%94%E8%AE%B0/","content":"<h1 id=\"C-primer笔记\"><a href=\"#C-primer笔记\" class=\"headerlink\" title=\"C++ primer笔记\"></a>C++ primer笔记</h1><h2 id=\"1-开始\"><a href=\"#1-开始\" class=\"headerlink\" title=\"1 开始\"></a>1 开始</h2><h3 id=\"1-2-初识输入输出\"><a href=\"#1-2-初识输入输出\" class=\"headerlink\" title=\"1.2 初识输入输出\"></a>1.2 初识输入输出</h3><ol>\n<li>cout 输出语句时，尽量要以 endl 结束，从而刷新缓存区，否则如果出现程序崩溃，输出可能还留在缓冲区中。</li>\n</ol>\n<h2 id=\"2-变量和基本类型\"><a href=\"#2-变量和基本类型\" class=\"headerlink\" title=\"2 变量和基本类型\"></a>2 变量和基本类型</h2><h3 id=\"2-2-变量\"><a href=\"#2-2-变量\" class=\"headerlink\" title=\"2.2 变量\"></a>2.2 变量</h3><ol>\n<li>extern：<ul>\n<li>只能作用在函数体外。</li>\n<li>extern 声明一个变量，如果赋予变量初值，则表示定义。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-5-处理类型\"><a href=\"#2-5-处理类型\" class=\"headerlink\" title=\"2.5 处理类型\"></a>2.5 处理类型</h3><ol>\n<li><p>类型别名：</p>\n<ul>\n<li>typedef double wages;</li>\n<li>using my_double &#x3D; double;</li>\n<li>在使用包含指针的类型别名的时候，不能简单地将类型别名替换成原类型，见下图。</li>\n</ul>\n <img src=\"/2023/03/05/C++%20primer%E7%AC%94%E8%AE%B0/typedef%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E4%B8%8Econst%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8.jpg\" class=\"\" title=\"typedef指针类型别名与const同时使用\">\n</li>\n<li><p>auto</p>\n</li>\n<li><p>decltype：<code>decltype(expression)</code> 返回表达式结果类型（可能是左值）。</p>\n</li>\n</ol>\n<h2 id=\"3字符串、向量和数组\"><a href=\"#3字符串、向量和数组\" class=\"headerlink\" title=\"3字符串、向量和数组\"></a>3字符串、向量和数组</h2><h2 id=\"4-表达式\"><a href=\"#4-表达式\" class=\"headerlink\" title=\"4 表达式\"></a>4 表达式</h2><h3 id=\"4-11-类型转换\"><a href=\"#4-11-类型转换\" class=\"headerlink\" title=\"4.11 类型转换\"></a>4.11 类型转换</h3><ol>\n<li>隐式转换</li>\n<li>显示转换<ul>\n<li>强制类型转换：(double)</li>\n<li>命名的强制类型转换：cast-name&lt;type&gt;(expression)<ul>\n<li><p>static_cast：常用于 void* 的具体化，较大的算术类型降级。</p>\n</li>\n<li><p>dynamic_cast：支持运行时类型识别。详细见 19.2 节。</p>\n</li>\n<li><p>const_cast：将 const 对象转换为非 const 对象，常常用于有函数重载的上下文。</p>\n  <img src=\"/2023/03/05/C++%20primer%E7%AC%94%E8%AE%B0/const_cast%E5%9C%A8%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.jpg\" class=\"\">\n</li>\n<li><p>reinterpret_cast：<strong>最好别用</strong>。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"5-语句\"><a href=\"#5-语句\" class=\"headerlink\" title=\"5 语句\"></a>5 语句</h2><h2 id=\"6-函数\"><a href=\"#6-函数\" class=\"headerlink\" title=\"6 函数\"></a>6 函数</h2><h2 id=\"7-类\"><a href=\"#7-类\" class=\"headerlink\" title=\"7 类\"></a>7 类</h2><p>一个好的习惯是：将类中的成员函数声明和定义分离，并尽量设置类的成员变量为私有。如此一来，用户代码只能通过声明的接口对类进行操作，类的实现者对类接口的修改不会影响到用户代码。</p>\n<img src=\"/2023/03/05/C++%20primer%E7%AC%94%E8%AE%B0/%E5%B0%86%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E5%88%86%E7%A6%BB.jpg\" class=\"\">\n\n<p>此时，将类以及与该类相关的友元接口声明在 <code>*.h</code> 文件中，并暴露给用户代码，即用户代码只需 <code>include &quot;*.h&quot;</code> 即可；类及相关友元接口的实现则定义在 <code>*.cpp</code> 中。</p>\n<h3 id=\"7-3-类的其它特性\"><a href=\"#7-3-类的其它特性\" class=\"headerlink\" title=\"7.3 类的其它特性\"></a>7.3 类的其它特性</h3><ol>\n<li><p>mutable 数据成员可以被 const 成员函数修改。</p>\n <img src=\"/2023/03/05/C++%20primer%E7%AC%94%E8%AE%B0/mutable.jpg\" class=\"\" title=\"mutable\"></li>\n</ol>\n<h3 id=\"7-5-再探构造函数\"><a href=\"#7-5-再探构造函数\" class=\"headerlink\" title=\"7.5 再探构造函数\"></a>7.5 再探构造函数</h3><h4 id=\"7-5-3-使用默认构造函数\"><a href=\"#7-5-3-使用默认构造函数\" class=\"headerlink\" title=\"7.5.3 使用默认构造函数\"></a>7.5.3 使用默认构造函数</h4><p><code>Sales_data obj;</code> √</p>\n<p><code>Sales_data obj();</code> ×，这是在声明函数。</p>\n<h4 id=\"7-5-4-隐式的类类型转换\"><a href=\"#7-5-4-隐式的类类型转换\" class=\"headerlink\" title=\"7.5.4 隐式的类类型转换\"></a>7.5.4 隐式的类类型转换</h4><ol>\n<li><p>只接受一个实参的构造函数，也叫做<strong>转换构造函数</strong>。</p>\n<p> <code>Sales_data obj = string(&quot;123&quot;);</code></p>\n</li>\n<li><p>但是，只允许<strong>一步类类型转化</strong>，比如 <code>Sales_data obj = &quot;123&quot;；</code> 就不被允许。</p>\n</li>\n<li><p>抑制构造函数定义的隐式转换：使用 <code>explicit</code> 关键字</p>\n <img src=\"/2023/03/05/C++%20primer%E7%AC%94%E8%AE%B0/explicit.jpg\" class=\"\" title=\"explicit\"></li>\n</ol>\n<h2 id=\"8-IO-库\"><a href=\"#8-IO-库\" class=\"headerlink\" title=\"8 IO 库\"></a>8 IO 库</h2><h2 id=\"9-顺序容器\"><a href=\"#9-顺序容器\" class=\"headerlink\" title=\"9 顺序容器\"></a>9 顺序容器</h2><h2 id=\"10-泛型\"><a href=\"#10-泛型\" class=\"headerlink\" title=\"10 泛型\"></a>10 泛型</h2>","categories":["C++"],"tags":["C++"]},{"title":"Hello World","url":"/2022/10/20/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"测试文章","url":"/2022/10/20/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/","content":"<p>这是一篇测试文章。</p>\n<ul>\n<li>测试在hexo-blog文件夹下运行hexo clean &amp;&amp; hexo deploy是否可以执行成功。√</li>\n<li>测试在hexo-blog文件夹下运行hexo generate &amp;&amp; hexo deploy是否可以执行成功。√</li>\n<li><strong>推荐</strong>：hexo g &amp;&amp; hexo d</li>\n</ul>\n<img src=\"/2022/10/20/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/%E6%98%9F%E5%A4%9C.jpg\" class=\"\" title=\"图片引用方法一\">\n\n","categories":["测试"],"tags":["测试"]},{"title":"牛客网——算法入门（栈）","url":"/2022/11/15/%E7%89%9B%E5%AE%A2%E7%BD%91%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%EF%BC%88%E6%A0%88%EF%BC%89/","content":"<h1 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h1><h2 id=\"AB2\"><a href=\"#AB2\" class=\"headerlink\" title=\"AB2\"></a>AB2</h2><h3 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。</p>\n<ol>\n<li><p>0&lt;&#x3D;pushV.length &#x3D;&#x3D; popV.length &lt;&#x3D;1000</p>\n</li>\n<li><p>-1000&lt;&#x3D;pushV[i]&lt;&#x3D;1000</p>\n</li>\n<li><p>pushV 的所有数字均不相同</p>\n</li>\n</ol>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：[1,2,3,4,5],[4,5,3,2,1]</span><br><span class=\"line\">返回值：true</span><br><span class=\"line\">说明：可以通过push(1)=&gt;push(2)=&gt;push(3)=&gt;push(4)=&gt;pop()=&gt;push(5)=&gt;pop()=&gt;pop()=&gt;pop()=&gt;pop()</span><br><span class=\"line\">这样的顺序得到[4,5,3,2,1]这个序列，返回true</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：[1,2,3,4,5],[4,3,5,1,2]</span><br><span class=\"line\">返回值：false</span><br><span class=\"line\">说明：由于是[1,2,3,4,5]的压入顺序，[4,3,5,1,2]的弹出顺序，要求4，3，5必须在1，2后压入，且1，2不能弹出，但是这样压入的顺序，1又不能在2之前弹出，所以无法形成的，返回false  </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>模拟栈操作。</p>\n<ol>\n<li>记popV的第一个元素为p<sub>1</sub>，那么pushV中p<sub>1</sub>之前元素全部顺序入栈，p<sub>1</sub>入栈再出栈；popV的后续元素如果依次等于栈顶元素，持续进行出栈操作，直至不相等或栈为空，记popV此时元素为p<sub>i</sub>。</li>\n<li>pushV中p<sub>1</sub>之后，p<sub>i</sub>之前的元素继续顺序入栈，而p<sub>i</sub>入栈再出栈；popV的后续元素如果依次等于栈顶元素，持续进行出栈操作，直至不相等或栈为空。</li>\n<li>……</li>\n<li>直到pushV中元素全部入栈，此时后续只有一种出栈方式，即栈中元素依次出栈与popV后续元素一一比较。如果某次不相等，则无法以pushV顺序压入，popV顺序弹出。</li>\n</ol>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">IsPopOrder</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; pushV,vector&lt;<span class=\"type\">int</span>&gt; popV)</span> </span>&#123;</span><br><span class=\"line\">        stack&lt;<span class=\"type\">int</span>&gt; s;</span><br><span class=\"line\">        <span class=\"type\">int</span> p_length = pushV.<span class=\"built_in\">size</span>(), v_length = popV.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p_length == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> cur_push_pos = <span class=\"number\">0</span>, cur_pop_pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(pushV[cur_push_pos] != popV[cur_pop_pos])&#123;</span><br><span class=\"line\">                s.<span class=\"built_in\">push</span>(pushV[cur_push_pos++]); <span class=\"comment\">// pushV中popV[cur_pop_pos]之前元素全部入栈</span></span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                cur_push_pos++;</span><br><span class=\"line\">                cur_pop_pos++; <span class=\"comment\">// popV[cur_pop_pos]入栈再出栈</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!s.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s.<span class=\"built_in\">top</span>() == popV[cur_pop_pos])&#123; <span class=\"comment\">// 是否连续出栈操作</span></span><br><span class=\"line\">                    s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                    cur_pop_pos++;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">while</span>(cur_push_pos &lt; p_length);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!s.<span class=\"built_in\">empty</span>() &amp;&amp; cur_pop_pos &lt; v_length)&#123; <span class=\"comment\">// pushV全部压入后，此时后续只有一种出栈</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s.<span class=\"built_in\">top</span>() == popV[cur_pop_pos])&#123;</span><br><span class=\"line\">                s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                cur_pop_pos++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.<span class=\"built_in\">empty</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","categories":["刷题"],"tags":["算法","数据结构","栈"]},{"title":"Ceph源码分析","url":"/2022/10/22/Ceph%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","content":"<h1 id=\"《Ceph源码分析》摘要\"><a href=\"#《Ceph源码分析》摘要\" class=\"headerlink\" title=\"《Ceph源码分析》摘要\"></a>《Ceph源码分析》摘要</h1><h2 id=\"Ceph整体结构\"><a href=\"#Ceph整体结构\" class=\"headerlink\" title=\"Ceph整体结构\"></a>Ceph整体结构</h2><h3 id=\"Ceph设计目标\"><a href=\"#Ceph设计目标\" class=\"headerlink\" title=\"Ceph设计目标\"></a>Ceph设计目标</h3><ol>\n<li>高可用性：Ceph使用数据多副本、纠删码提供数据冗余。</li>\n<li>高可扩展性<ul>\n<li>集群容量可以伸缩，可以任意添加和删除存储节点、存储设备。</li>\n<li>系统性能随集群的增加而线性增加。</li>\n</ul>\n</li>\n<li>大规模：Ceph存储系统的规模可以扩展到成千上万节点。</li>\n</ol>\n<h3 id=\"Ceph基本架构图\"><a href=\"#Ceph基本架构图\" class=\"headerlink\" title=\"Ceph基本架构图\"></a>Ceph基本架构图</h3><p>Ceph整体架构有三层</p>\n<ol>\n<li>最底层最核心的RADOS对象存储系统：RADOS（reliable, autonomous, distributed object store）是一个可靠的、自组织的、可自动修复、自我管理的分布式对象存储系统。其内部包括 ceph-osd 后台服务进程和 ceph-mon 监控进程。  </li>\n<li>中间层librados库：用于本地或远程通过网络访问RADOS对象存储系统。支持多种语言，如C&#x2F;C++、Java、Python等。</li>\n<li>最上层Ceph不同形式的存储接口实现<ul>\n<li>块存储结构。</li>\n<li>对象存储接口。</li>\n<li>文件系统接口。</li>\n</ul>\n</li>\n</ol>\n<img src=\"/2022/10/22/Ceph%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ceph%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E5%9B%BE.png\" class=\"\" title=\"Ceph基本架构图\">\n\n<h3 id=\"Ceph客户端接口\"><a href=\"#Ceph客户端接口\" class=\"headerlink\" title=\"Ceph客户端接口\"></a>Ceph客户端接口</h3><h4 id=\"RBD\"><a href=\"#RBD\" class=\"headerlink\" title=\"RBD\"></a>RBD</h4><p>RBD（rados block device）通过 librbd 库对应用提供块存储，主要面向云平台的虚拟机提供虚拟磁盘。传统 SAN 就是块存储，通过 SCSI 或者 FC 接口给应用提供一个独立的 LUN 或者卷。RBD 类似于传统的 SAN 存储，都提供数据块级别的访问。  </p>\n<h4 id=\"CephFS\"><a href=\"#CephFS\" class=\"headerlink\" title=\"CephFS\"></a>CephFS</h4><p>CephFS 通过在 RADOS 基础之上增加了 MDS ( Metadata Server) 来提供文件存储。它提供了 libcephfs 库和标准的 P0SIX 文件接口。 CephFS 类似于传统的 NAS 存储，通过 NFS 或者 CIFS 协议提供文件系统或者文件目录服务。</p>\n<h4 id=\"RadosGW\"><a href=\"#RadosGW\" class=\"headerlink\" title=\"RadosGW\"></a>RadosGW</h4><p>（看不太明白</p>\n<h3 id=\"RADOS\"><a href=\"#RADOS\" class=\"headerlink\" title=\"RADOS\"></a>RADOS</h3><p>RADOS完成了一个存储系统的核心功能，包括以下部分：</p>\n<h4 id=\"Monitor\"><a href=\"#Monitor\" class=\"headerlink\" title=\"Monitor\"></a>Monitor</h4><p>Monitor模块为整个存储集群提供全局的配置和系统信息。</p>\n<ol>\n<li>它是一个独立部署的daemon进程，通过组成Monitor集群来保证自己的高可用性。</li>\n<li>通过Paxos算法实现自己数据的一致性。</li>\n<li>提供整个存储系统的节点信息等全局配置信息。</li>\n</ol>\n<p>Cluster Map保存了系统的全局信息，主要包括：</p>\n<ol>\n<li>Monitor Map<ul>\n<li>包括集群的fsid；</li>\n<li>所有Monitor的地址和端口；</li>\n<li>current epoch。</li>\n</ul>\n</li>\n<li>OSD Map：所有OSD的列表和OSD的状态等。</li>\n<li>MDS Map：所有的MDS的列表和状态。</li>\n</ol>\n<h4 id=\"对象存储\"><a href=\"#对象存储\" class=\"headerlink\" title=\"对象存储\"></a>对象存储</h4><p>这里所说的对象是指 RADOS 对象，要和 RadosGW 的 S3 或者 Swift 接口的对象存储区分开来。对象是数据存储的基本单元，一般默认 4MB 大小。下图是一个对象的示意图。</p>\n<img src=\"/2022/10/22/Ceph%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%AF%B9%E8%B1%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" class=\"\" title=\"对象示意图\">\n\n<p>一个对象由三个部分组成：</p>\n<ol>\n<li>对象标志ID；</li>\n<li>对象的数据，其在本地文件系统中对应一个文件，对象的数据就保存在文件中；</li>\n<li>对象的元数据，以key-value形式保存。</li>\n</ol>\n<h4 id=\"pool和PG的概念\"><a href=\"#pool和PG的概念\" class=\"headerlink\" title=\"pool和PG的概念\"></a>pool和PG的概念</h4><p>pool是一个抽象的存储池。它规定了数据冗余的类型以及对应的副本分布策略（副本类型和纠删码类型等）。一个pool由多个PG构成。</p>\n<p>PG（placement group）是一个对象的集合，该集合中的所有对象有相同的放置策略：对象的副本都分布在相同的OSD列表上。一个对象只能属于一个PG，一个PG对应于放置在其上的OSD列表。一个OSD上可以分布多个PG。</p>\n<img src=\"/2022/10/22/Ceph%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/PG%E6%A6%82%E5%BF%B5%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" class=\"\" title=\"PG概念示意图\">\n\n<ol>\n<li>PG1和PG2都属于同一个pool，都是副本类型，且都是两副本；</li>\n<li>PG1和PG2里包含许多对象，PG1 上的所有对象，主从副本分布在 0SD1 和<br> 0SD2 上，PG2 上的所有对象的主从副本分布在0SD2 和 OSD3 上；</li>\n<li>一个对象只能属于一个PG，一个PG包含多个对象；</li>\n<li>一个 PG 的副本分布在对应的 OSD 列表中。在一个 OSD 上可以分布多个 PG。示例中 PG1 和 PG2 的从副本都分布在 0SD2 上。</li>\n</ol>\n<h4 id=\"对象寻址过程\"><a href=\"#对象寻址过程\" class=\"headerlink\" title=\"对象寻址过程\"></a>对象寻址过程</h4><p>1</p>\n<h4 id=\"数据读写过程\"><a href=\"#数据读写过程\" class=\"headerlink\" title=\"数据读写过程\"></a>数据读写过程</h4><p>1</p>\n<h4 id=\"数据均衡\"><a href=\"#数据均衡\" class=\"headerlink\" title=\"数据均衡\"></a>数据均衡</h4><p>1</p>\n<h4 id=\"Peering\"><a href=\"#Peering\" class=\"headerlink\" title=\"Peering\"></a>Peering</h4><p>1</p>\n<h4 id=\"Recovery和Backfill\"><a href=\"#Recovery和Backfill\" class=\"headerlink\" title=\"Recovery和Backfill\"></a>Recovery和Backfill</h4><p>1</p>\n<h4 id=\"纠删码\"><a href=\"#纠删码\" class=\"headerlink\" title=\"纠删码\"></a>纠删码</h4><p>1</p>\n<h4 id=\"快照和克隆\"><a href=\"#快照和克隆\" class=\"headerlink\" title=\"快照和克隆\"></a>快照和克隆</h4><p>1</p>\n<h4 id=\"Cache-Tier\"><a href=\"#Cache-Tier\" class=\"headerlink\" title=\"Cache Tier\"></a>Cache Tier</h4><p>1</p>\n<h4 id=\"Scrub\"><a href=\"#Scrub\" class=\"headerlink\" title=\"Scrub\"></a>Scrub</h4><p>1</p>\n<h4 id=\"本章小结\"><a href=\"#本章小结\" class=\"headerlink\" title=\"本章小结\"></a>本章小结</h4><p>1</p>\n<h2 id=\"Ceph通用模块\"><a href=\"#Ceph通用模块\" class=\"headerlink\" title=\"Ceph通用模块\"></a>Ceph通用模块</h2><p>Ceph源代码通用库中的一些关键而又复杂的数据结构。大多定义于<code>src/common/</code>中</p>\n<ol>\n<li>Object和Buffer普遍使用；</li>\n<li>线程池ThreadPool可以提高消息处理的并发能力；</li>\n<li>Finisher提供异步操作时来执行回调函数；</li>\n<li>Throttle在系统的各个模块各个环节都能看到，用来限制系统的请求，避免瞬时大量请求对系统的冲击；</li>\n<li>SafteTimer提供定时器，为超时和定时任务等提供了相应的机制。</li>\n</ol>\n<h3 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h3><p>对象Object默认为4MB大小的数据块。一个对象对应本地文件系统中的一个文件。在代码实现中，有object、sobject、hobject、ghobject等不同的类。大多位于<code>src/include/object.h</code>中。</p>\n<h4 id=\"object-t\"><a href=\"#object-t\" class=\"headerlink\" title=\"object_t\"></a>object_t</h4><p>object_t对应本地文件系统中的一个文件，name就是对象名。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">object_t</span>&#123;</span><br><span class=\"line\">\tstring name;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"sobject-t\"><a href=\"#sobject-t\" class=\"headerlink\" title=\"sobject_t\"></a>sobject_t</h4><p>sobject_t在object_t之上增加了snapshot信息，用于标识是否是快照对象。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">sobject_t</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">object_t</span> oid;</span><br><span class=\"line\">\t<span class=\"type\">snapid_t</span> snap; <span class=\"comment\">// 快照对象的对应的快照序号；若不是快照对象（也就是head对象），snap字段则为CEPH_NOSNAP值</span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"hobject-t\"><a href=\"#hobject-t\" class=\"headerlink\" title=\"hobject_t\"></a>hobject_t</h4><p>hobject_t 是 hash object 的缩写。位于<code>src\\common\\hobject.h</code>中。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hobject_t</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">object_t</span> oid;</span><br><span class=\"line\">    <span class=\"type\">snapid_t</span> snap;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> hash; <span class=\"comment\">// hash和key不能同时设置，hash值一般设为pg的id值</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> max;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> nibblewise_key_cache;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> hash_reverse_bits;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int64_t</span> pool; <span class=\"comment\">// 所在pool的id</span></span><br><span class=\"line\">    std::string nspace; <span class=\"comment\">// 一般为空，用于标识特殊的对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    std::string key; <span class=\"comment\">// 对象的特殊标记</span></span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ghobject-t\"><a href=\"#ghobject-t\" class=\"headerlink\" title=\"ghobject_t\"></a>ghobject_t</h4><p>在hobject_t基础上，添加generation和shard_id字段，用于纠删码模式下的PG。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ghobject_t</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">gen_t</span> NO_GEN = UINT64_MAX;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">bool</span> max = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"type\">shard_id_t</span> shard_id = <span class=\"type\">shard_id_t</span>::NO_SHARD; <span class=\"comment\">// 标识对象所在的OSD在纠删码类型的PG中的序号；如果在副本类型的PG中，那么字段就设置为NO_SHARD(-1)</span></span><br><span class=\"line\">    <span class=\"type\">hobject_t</span> hobj;</span><br><span class=\"line\">    <span class=\"type\">gen_t</span> generation = NO_GEN; <span class=\"comment\">// 记录对象的版本号。当PG为纠删码类型时，写操作需要区别写前后两个版本的object，此时该字段保存对象的上一个版本，当写失败时，可以rollback到上一个版本</span></span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Buffer\"><a href=\"#Buffer\" class=\"headerlink\" title=\"Buffer\"></a>Buffer</h3><p>buffer是一个命名空间，里面定义了buffer相关的数据结构。</p>\n<h4 id=\"buffer-raw\"><a href=\"#buffer-raw\" class=\"headerlink\" title=\"buffer::raw\"></a>buffer::raw</h4><p>位于<code>src/include/buffer_raw.h</code>中，是一个基类，其子类完成buffer数据空间的分配。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ceph</span>::buffer::v15_2_0::raw&#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"type\">char</span> *data;  <span class=\"comment\">// 数据指针</span></span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> len; <span class=\"comment\">// 数据长度</span></span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tceph::atomic&lt;<span class=\"type\">unsigned</span>&gt; nref&#123;<span class=\"number\">0</span>&#125;; <span class=\"comment\">// 引用计数</span></span><br><span class=\"line\">\tstd::aligned_storage&lt;<span class=\"built_in\">sizeof</span>(ptr_node),<span class=\"built_in\">alignof</span>(ptr_node)&gt;::type bptr_storage; <span class=\"comment\">// 大小为sizeof(ptr_node)，alignof(ptr_node)对齐的类型。用于ptr_node的构造(new placement方式)，实际并未使用</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// 指定数据段的校验值</span></span><br><span class=\"line\">    std::pair&lt;<span class=\"type\">size_t</span>, <span class=\"type\">size_t</span>&gt; last_crc_offset &#123;std::numeric_limits&lt;<span class=\"type\">size_t</span>&gt;::<span class=\"built_in\">max</span>(), std::numeric_limits&lt;<span class=\"type\">size_t</span>&gt;::<span class=\"built_in\">max</span>()&#125;;</span><br><span class=\"line\">    std::pair&lt;<span class=\"type\">uint32_t</span>, <span class=\"type\">uint32_t</span>&gt; last_crc_val;</span><br><span class=\"line\">\t<span class=\"keyword\">mutable</span> ceph::spinlock crc_spinlock; </span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下列类继承了<code>buffer::raw</code>，实现了data对应内存空间的申请，定义于<code>src/common/buffer.cc</code>中：</p>\n<ol>\n<li>class raw_combined：分配的对象于data buffer分配在一个buffer上，data处于buffer的开头，object为buffer尾；</li>\n<li>class raw_malloc：实现了用 malloc 函数分配内存空间的功能；</li>\n<li>class buffer::raw_posix_aligned：调用了函数 posix_memaligii 来申请内存地址对齐<br> 的内存空间；</li>\n<li>class raw_static：data buffer使用static buffer；</li>\n<li>class buffer::raw_hack_aligned：在系统不支持内存对齐申请的情况下自己实现<br> 了内存地址的对齐；</li>\n<li>class buffer::raw_char：使用了 C++ 的 new 操作符来申请内存空间； </li>\n<li>class buffer::raw_claimed_char：不负责释放资源，因此可以是局部变量。针对new创建的buffer，则需手动显示释放；</li>\n<li>class buffer::raw_claim_buffer：接收自定义删除器。</li>\n</ol>\n<h4 id=\"buffer-ptr\"><a href=\"#buffer-ptr\" class=\"headerlink\" title=\"buffer::ptr\"></a>buffer::ptr</h4><p>是对于buffer::raw的一个部分数据段，定义于<code>src/include/buffer.h</code>中。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CEPH_BUFFER_API</span> ptr&#123;</span><br><span class=\"line\">    raw *_raw;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> _off, _len; <span class=\"comment\">// 起始偏移量，长度</span></span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/2022/10/22/Ceph%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/raw%E5%92%8Cptr%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" class=\"\" title=\"raw和ptr示意图\">\n\n<h4 id=\"buffer-list\"><a href=\"#buffer-list\" class=\"headerlink\" title=\"buffer::list\"></a>buffer::list</h4><p>是多个buffer::ptr的列表，也就是多个内存数据段的列表，定义于<code>src/include/buffer.h</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CEPH_BUFFER_API</span> list&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">class</span> <span class=\"title class_\">buffers_t</span>&#123; <span class=\"comment\">// 底层单链表实现</span></span><br><span class=\"line\">\t\tptr_hook _root;</span><br><span class=\"line\">\t\tptr_hook *_tail;</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"comment\">// 添加到头部</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_front</span><span class=\"params\">(reference item)</span> </span>&#123;</span><br><span class=\"line\">            item.next = _root.next;</span><br><span class=\"line\">            _root.next = &amp;item;</span><br><span class=\"line\">            _tail = _tail == &amp;_root ? &amp;item : _tail;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">buffers_t</span> _buffers; <span class=\"comment\">// 自己的私有bits</span></span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> _len;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（list结构大改，还需要仔细阅读原书和源码</strong></p>\n<h3 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h3><p>ThreadPool定义于<code>src/common/WorkQueue.h</code>中。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadPool</span> : <span class=\"keyword\">public</span> <span class=\"type\">md_config_obs_t</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tCephContext *cct;</span><br><span class=\"line\">  \tstd::string name; \t\t\t\t\t\t<span class=\"comment\">// 线程名？</span></span><br><span class=\"line\">  \tstd::string thread_name; </span><br><span class=\"line\">  \tstd::string lockname; \t\t\t\t\t<span class=\"comment\">// 锁名</span></span><br><span class=\"line\">  \tceph::mutex _lock; \t\t\t\t\t\t<span class=\"comment\">// 线程互斥锁，也是工作队列访问互斥的锁</span></span><br><span class=\"line\">  \tceph::condition_variable _cond;\t\t\t<span class=\"comment\">// 锁对应的条件变量</span></span><br><span class=\"line\">  \t<span class=\"type\">bool</span> _stop; \t\t\t\t\t\t\t<span class=\"comment\">// 线程池是否停止工作的标志</span></span><br><span class=\"line\">  \t<span class=\"type\">int</span> _pause; \t\t\t\t\t\t\t<span class=\"comment\">// 暂停中止线程池的标志</span></span><br><span class=\"line\">  \t<span class=\"type\">int</span> _draining;</span><br><span class=\"line\"> \tceph::condition_variable _wait_cond;</span><br><span class=\"line\">    </span><br><span class=\"line\">    std::vector&lt;WorkQueue_*&gt; work_queues; \t<span class=\"comment\">// 工作队列[集和]</span></span><br><span class=\"line\">    <span class=\"type\">int</span> next_work_queue = <span class=\"number\">0</span>;\t\t\t\t<span class=\"comment\">// 下一次访问的工作队列</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    std::set&lt;WorkThread*&gt; _threads;\t\t\t<span class=\"comment\">// 线程池中的工作线程</span></span><br><span class=\"line\">    std::list&lt;WorkThread*&gt; _old_threads;  \t<span class=\"comment\">// 等待进joined操作的线程</span></span><br><span class=\"line\">  \t<span class=\"type\">int</span> processing;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一般情况下，一个工作队列对应一个类型的后台处理任务，一个线程池对应一个工作队列，专门用于处理该类型的任务。如果是后台任务，又不紧急，就可以将多个工作队列放置到一个线程池中，该线程池可以处理不同类型的任务。</p>\n<p>线程池的实现主要包括：</p>\n<ol>\n<li>线程池的启动过程；</li>\n<li>线程池对应的工作队列管理；</li>\n<li>线程池对应的执行函数如何执行任务。</li>\n</ol>\n<h4 id=\"线程池的启动\"><a href=\"#线程池的启动\" class=\"headerlink\" title=\"线程池的启动\"></a>线程池的启动</h4><p>ThreadPool::start()用来启动线程池，其在加锁的情况下，调用函数 start_threads，该函数检査当前线程数，如果小于配置的线程池，就创建新的工作线程。定义于<code>src/common/WorkQueue.cc</code>。</p>\n<h4 id=\"工作队列\"><a href=\"#工作队列\" class=\"headerlink\" title=\"工作队列\"></a>工作队列</h4><p>工作队列（WorkQueue) 定义了线程池要处理的任务。</p>\n<ol>\n<li>任务类型在模板参数中指定；</li>\n<li>在构造函数里，就把自己加入到线程池的工作队列集合中；</li>\n<li>WorkQueue实现了部分功能：进队列、出队列、加锁；</li>\n<li>部分功能需要使用者定义，如定义保存任务的容器，添加和删除的方法，以及如何处理任务的方法。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WorkQueue</span> : <span class=\"keyword\">public</span> WorkQueue_ &#123;</span><br><span class=\"line\">    ThreadPool *pool;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Add a work item to the queue.</span></span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> _enqueue(T *) = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// Dequeue a previously submitted work item.</span></span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> <span class=\"type\">void</span> _dequeue(T *) = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// Dequeue a work item and return the original submitted pointer.</span></span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> T *_dequeue() = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"comment\">// Process a work item. Called from the worker threads.</span></span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> <span class=\"type\">void</span> _process(T *t, TPHandle &amp;) = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">WorkQueue</span>(std::string n,</span><br><span class=\"line\">\t    \tceph::timespan ti, ceph::timespan sti,</span><br><span class=\"line\">\t    \tThreadPool* p)</span><br><span class=\"line\">      \t\t: <span class=\"built_in\">WorkQueue_</span>(std::<span class=\"built_in\">move</span>(n), ti, sti), <span class=\"built_in\">pool</span>(p) &#123;</span><br><span class=\"line\">      \tpool-&gt;<span class=\"built_in\">add_work_queue</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">queue</span><span class=\"params\">(T *item)</span> </span>&#123; <span class=\"comment\">// 进队列</span></span><br><span class=\"line\">     \tpool-&gt;_lock.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">     \t<span class=\"type\">bool</span> r = _enqueue(item);</span><br><span class=\"line\">     \tpool-&gt;_cond.<span class=\"built_in\">notify_one</span>();</span><br><span class=\"line\">     \tpool-&gt;_lock.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dequeue</span><span class=\"params\">(T *item)</span> </span>&#123; <span class=\"comment\">// 出队列</span></span><br><span class=\"line\">      \tpool-&gt;_lock.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">      \t_dequeue(item);</span><br><span class=\"line\">      \tpool-&gt;_lock.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      \tpool-&gt;_lock.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">      \t_clear();</span><br><span class=\"line\">      \tpool-&gt;_lock.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123; pool-&gt;<span class=\"built_in\">lock</span>(); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> </span>&#123; pool-&gt;<span class=\"built_in\">unlock</span>(); &#125;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"线程池的执行函数\"><a href=\"#线程池的执行函数\" class=\"headerlink\" title=\"线程池的执行函数\"></a>线程池的执行函数</h4><p>ThreadPool::worker定义于<code>src/common/WorkQueue.cc</code>中。</p>\n<ol>\n<li>首先检查_stop标志，确保线程池没有关闭；</li>\n<li>调用函数join_old_threads把旧的工作线程释放掉。检査如果线程数量大于配置的数量 _num_threads，就把当前线程从线程集合中删除，并加入_old_threads队列中，并退<br> 出循环；</li>\n<li>如果线程池没有中止（_pause）且work_queues不为空，就从next_work_queue开始，边理每一个工作队列，如果工作会裂不为空，就取出一个item，调用工作队列的处理函数做处理。</li>\n</ol>\n<h4 id=\"超时检查\"><a href=\"#超时检查\" class=\"headerlink\" title=\"超时检查\"></a>超时检查</h4><p>TPHandle是一个有意思的事情，定义于<code>src/common/WorkerQueue.h</code>中。每次线程函数执行时，都会设置一个 grace 超时时间，当线程执行超过该时间，就认为是 unhealthy 的状态。当执行时间超过 suicide_grace 时，OSD 就会产生断言而导致自杀，代码如下：  </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadPool</span>::TPHandle : <span class=\"keyword\">public</span> HBHandle &#123;</span><br><span class=\"line\">        <span class=\"keyword\">friend</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadPool</span>;</span><br><span class=\"line\">        CephContext *cct;\t\t\t\t</span><br><span class=\"line\">        ceph::heartbeat_handle_d *hb;\t<span class=\"comment\">// 心跳</span></span><br><span class=\"line\">        ceph::timespan grace;\t\t\t<span class=\"comment\">// 超时</span></span><br><span class=\"line\">        ceph::timespan suicide_grace;\t<span class=\"comment\">// 自杀的超时时间</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"built_in\">TPHandle</span>(CephContext *cct, ceph::heartbeat_handle_d *hb,</span><br><span class=\"line\">                 ceph::timespan grace, ceph::timespan suicide_grace)</span><br><span class=\"line\">            : <span class=\"built_in\">cct</span>(cct), <span class=\"built_in\">hb</span>(hb), <span class=\"built_in\">grace</span>(grace), <span class=\"built_in\">suicide_grace</span>(suicide_grace) &#123;&#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reset_tp_timeout</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> <span class=\"keyword\">final</span></span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">suspend_tp_timeout</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> <span class=\"keyword\">final</span></span>;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ShardedThreadPool\"><a href=\"#ShardedThreadPool\" class=\"headerlink\" title=\"ShardedThreadPool\"></a>ShardedThreadPool</h4><p>ThreadPool 实现的线程池，其每个线程都有机会处理工作队列的任意一个任务。这就会导致一个问题：如果任务之间有互斥性，那么正在处理该任务的两个线程有一个必须等待另一个处理完成后才能处理，从而导致线程的阻塞，性能下降。</p>\n<p>具体如何实现 Shard 方式，还需要使用者自己去实现。其基本的思想就是：每个线程对应一个任务队列，所有需要顺序执行的任务都放在同一个线程的任务队列里，全部由该线程执行。 定义于<code>src/common/WorkerQueue.h</code>中 </p>\n<h3 id=\"Finisher\"><a href=\"#Finisher\" class=\"headerlink\" title=\"Finisher\"></a>Finisher</h3><p>类Finisher用来完成回调函数Context的执行，其内部有一个FinisherThread线程来用于执行Context回调函数。定义于<code>src/common/Finisher.h</code>中。</p>\n<h3 id=\"Throttle\"><a href=\"#Throttle\" class=\"headerlink\" title=\"Throttle\"></a>Throttle</h3><p>类Throttle用来限制消费的资源数量（也常称为槽位 “slot”），当请求的 slot 数量达到max值时，请求就会被阻塞，直到有新的槽位释放出来，定义于<code>src/common/Throttle.h</code>中，代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Throttle</span> <span class=\"keyword\">final</span> : <span class=\"keyword\">public</span> ThrottleInterface &#123;</span><br><span class=\"line\">  \tCephContext *cct;</span><br><span class=\"line\">  \t<span class=\"type\">const</span> std::string name;</span><br><span class=\"line\">  \tPerfCountersRef logger;</span><br><span class=\"line\">  \tstd::atomic&lt;<span class=\"type\">int64_t</span>&gt; count = &#123; <span class=\"number\">0</span> &#125;, max = &#123; <span class=\"number\">0</span> &#125;;  \t<span class=\"comment\">// 当前占用的slot数量和slot数量的最大值</span></span><br><span class=\"line\">  \tstd::mutex lock;\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 等待的锁</span></span><br><span class=\"line\">  \tstd::list&lt;std::condition_variable&gt; conds;\t\t\t<span class=\"comment\">// 等待的条件变量</span></span><br><span class=\"line\">    ......</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int64_t</span> c = <span class=\"number\">1</span>, <span class=\"type\">int64_t</span> m = <span class=\"number\">0</span>)</span></span>;\t\t\t\t<span class=\"comment\">// 获取c个slot，如果m不为0值，则将max设置为m的值；成功获取c个slot后，就返回true，否则阻塞等待</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">get_or_fail</span><span class=\"params\">(<span class=\"type\">int64_t</span> c = <span class=\"number\">1</span>)</span></span>;\t\t\t\t\t<span class=\"comment\">// 当获取不到c个slot时，直接返回false，不阻塞等待</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int64_t</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"type\">int64_t</span> c = <span class=\"number\">1</span>)</span> <span class=\"keyword\">override</span></span>;\t\t\t\t<span class=\"comment\">// 释放c个slot资源</span></span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SafeTimer\"><a href=\"#SafeTimer\" class=\"headerlink\" title=\"SafeTimer\"></a>SafeTimer</h3><p>类SafeTimer实现了定时器的功能，定义于<code>src/common/Timer.h</code>中，代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">Mutex</span>&gt; <span class=\"keyword\">class</span> <span class=\"title class_\">CommonSafeTimer</span> &#123;</span><br><span class=\"line\">    CephContext *cct;</span><br><span class=\"line\">    Mutex &amp;lock;</span><br><span class=\"line\">    std::condition_variable_any cond;</span><br><span class=\"line\">    <span class=\"type\">bool</span> safe_callbacks;\t\t\t\t\t\t\t<span class=\"comment\">// 是否是safe_callbacks</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CommonSafeTimerThread</span>&lt;Mutex&gt;;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">CommonSafeTimerThread</span>&lt;Mutex&gt; *thread;\t\t<span class=\"comment\">// 定时器执行线程</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">using</span> <span class=\"type\">clock_t</span> = ceph::mono_clock;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> <span class=\"type\">scheduled_map_t</span> = std::multimap&lt;<span class=\"type\">clock_t</span>::time_point, Context *&gt;;</span><br><span class=\"line\">    <span class=\"type\">scheduled_map_t</span> schedule;\t<span class=\"comment\">// 目标时间和定时任务执行函数Context</span></span><br><span class=\"line\">    <span class=\"keyword\">using</span> <span class=\"type\">event_lookup_map_t</span> = std::map&lt;Context *, <span class=\"type\">scheduled_map_t</span>::iterator&gt;;</span><br><span class=\"line\">    <span class=\"type\">event_lookup_map_t</span> events;\t<span class=\"comment\">// 定时任务&lt;--&gt;定时任务在schedule中的位置映射</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> stopping;\t\t\t\t<span class=\"comment\">// 是否停止</span></span><br><span class=\"line\">    ......</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 添加定时任务</span></span><br><span class=\"line\">    <span class=\"function\">Context *<span class=\"title\">add_event_after</span><span class=\"params\">(ceph::timespan duration, Context *callback)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Context *<span class=\"title\">add_event_after</span><span class=\"params\">(<span class=\"type\">double</span> seconds, Context *callback)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Context *<span class=\"title\">add_event_at</span><span class=\"params\">(<span class=\"type\">clock_t</span>::time_point when, Context *callback)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Context *<span class=\"title\">add_event_at</span><span class=\"params\">(ceph::real_clock::time_point when, Context *callback)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 取消定时任务</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cancel_event</span><span class=\"params\">(Context *callback)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">cancel_all_events</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 定时任务执行</span></span><br><span class=\"line\">    <span class=\"comment\">/* 循环检查schedule中的任务是否到期，由于schedule中是按照时间升序排列的，因此第一任务没有到期就终止循环；</span></span><br><span class=\"line\"><span class=\"comment\">       如果第一任务到期，则调用callback执行，需要注意如果是非safe_callbacks，则需要先获取lock再执行callback函数。*/</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">timer_thread</span><span class=\"params\">()</span></span>; </span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">using</span> SafeTimer = <span class=\"keyword\">class</span> CommonSafeTimer&lt;ceph::mutex&gt;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Ceph网络通信\"><a href=\"#Ceph网络通信\" class=\"headerlink\" title=\"Ceph网络通信\"></a>Ceph网络通信</h2><p>本章介绍 Ceph 网络通信模块，这是客户端和服务器通信的底层模块，用来在客户端和服务器之间接收和发送请求。其实现功能比较清晰，是一个相对较独立的模块理解起来比较容易，所以首先介绍它。  </p>\n<h3 id=\"Ceph网络通信框架\"><a href=\"#Ceph网络通信框架\" class=\"headerlink\" title=\"Ceph网络通信框架\"></a>Ceph网络通信框架</h3><p>—个分布式存储系统需要一个稳定的底层网络通信模块，用于各节点之间的互联互通。对于一个网络通信系统，要求如下：</p>\n<ol>\n<li>高性能：带宽和延时；</li>\n<li>稳定可靠：数据不丢包，在网络中断时，实现重连等异常处理。</li>\n</ol>\n<p>网络通信模块的实现在源代码<code>src/msg</code>的目录下，其首先定义了一个网络通信的框架，三个子目录里分别对应：Simple、Async、XIO三种不同的实现方式。</p>\n<p>Simple 是比较简单，目前比较稳定的实现，系统默认的用于生产环境的方式。它最大的特点是：每一个网络链接，都会创建两个线程，一个专门用于接收，一个专门用于发送。这种模式实现比较简单，但是对于大规模的集群部署，大量的链接会产生大量的线程，会消耗 CPU 资源，影响性能。   </p>\n<p>Async 模式使用了基于事件的 I&#x2F;O 多路复用模式。这是目前网络通信中广泛采用的方式， 但是在 Ceph 中，官方宣称这种方式还处于试验阶段，不够稳定，还不能用于生产环境（📕中的Ceph是10.2.1老版本，<strong>新版本中似乎只有Async模式了</strong>）。</p>\n<p>XIO 方式使用了开源的网络通信库 accelio 来实现。这种方式需要依赖第三方的库 accelio 稳定性， 需要对 accelio 的使用方式以及代码实现都比较熟悉。目前也处于试验阶段。特别注意的是， 前两种方式只支持 TCP&#x2F;IP 协议，XIO 可以支持 Infiniband 网络。</p>\n<p>在 msg 目录下定义了网络通信的抽象框架，它完成了通信接口和具体实现的分离。在其下分别有 <code>msg/simple</code> 子目录、 <code>msg/Async</code> 子目录、 <code>msg/xio</code> 子目录，分别对应三种不同的实现。 </p>\n<h4 id=\"Message\"><a href=\"#Message\" class=\"headerlink\" title=\"Message\"></a>Message</h4><p>类Message是所有消息的基类，任何要发送的消息，都要继承该类，定义于<code>src/msg/Message.h</code>中，格式如下图所示。</p>\n<img src=\"/2022/10/22/Ceph%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E6%A0%BC%E5%BC%8F.png\" class=\"\" title=\"消息发送格式\">\n\n<p>其中，header是消息头，类似一个消息的信封（envelope），user_data是用于要发送的实际数据，footer是一个消息的结束标记，如下所示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Message</span> : <span class=\"keyword\">public</span> RefCountedObject &#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    ceph_msg_header header; \t<span class=\"comment\">// 消息头</span></span><br><span class=\"line\">    ceph_msg_footer footer;\t\t<span class=\"comment\">// 消息尾</span></span><br><span class=\"line\">    ceph::buffer::list payload; <span class=\"comment\">// &quot;front&quot; unaligned blob</span></span><br><span class=\"line\">    ceph::buffer::list middle;  <span class=\"comment\">// &quot;middle&quot; unaligned blob</span></span><br><span class=\"line\">    ceph::buffer::list data;\t<span class=\"comment\">// data payload (page-alignment will be preserved where possible)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 消息相关的时间戳</span></span><br><span class=\"line\">    <span class=\"type\">utime_t</span> recv_stamp;\t\t\t<span class=\"comment\">// 开始接收数据的时间戳</span></span><br><span class=\"line\">    <span class=\"type\">utime_t</span> dispatch_stamp;\t\t<span class=\"comment\">// dispatch的时间戳</span></span><br><span class=\"line\">    <span class=\"type\">utime_t</span> throttle_stamp;\t\t<span class=\"comment\">// 获取throttle的slot的时间戳</span></span><br><span class=\"line\">    <span class=\"type\">utime_t</span> recv_complete_stamp;<span class=\"comment\">// 接收完成的时间戳</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ConnectionFRef connection;\t<span class=\"comment\">// 网络连接类</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> magic = <span class=\"number\">0</span>;\t\t\t<span class=\"comment\">// 消息的魔术字</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">    boost::intrusive::list_member_hook&lt;&gt; dispatch_q; <span class=\"comment\">//boost::intrusive需要的字段</span></span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面分别介绍其中的重要参数。</p>\n<p>ceph_msg_header 为消息头，它定义了消息传输相关的元数据，在<code>src/include/msgr.h</code>中：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ceph_msg_header</span> &#123;</span><br><span class=\"line\">\t__le64 seq;       \t\t<span class=\"comment\">// 当前session内消息的唯一序号</span></span><br><span class=\"line\">\t__le64 tid;       \t\t<span class=\"comment\">// 消息的全局唯一id</span></span><br><span class=\"line\">\t__le16 type;      \t\t<span class=\"comment\">// 消息类型</span></span><br><span class=\"line\">\t__le16 priority;  \t\t<span class=\"comment\">// 优先级</span></span><br><span class=\"line\">\t__le16 version;   \t\t<span class=\"comment\">// 消息编码的版本</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t__le32 front_len;\t\t<span class=\"comment\">// payload的长度</span></span><br><span class=\"line\">\t__le32 middle_len;\t\t<span class=\"comment\">// middle的长度</span></span><br><span class=\"line\">\t__le32 data_len;  \t\t<span class=\"comment\">// data的长度</span></span><br><span class=\"line\">\t__le16 data_off;  \t\t<span class=\"comment\">// 对象的数据偏移量</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">ceph_entity_name</span> src; \t<span class=\"comment\">// 消息源</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 一些旧的代码，用于兼容，如果为0就忽略</span></span><br><span class=\"line\">\t__le16 compat_version;</span><br><span class=\"line\">\t__le16 reserved;</span><br><span class=\"line\">\t__le32 crc;       \t\t<span class=\"comment\">// 消息头的crc32c校验信息</span></span><br><span class=\"line\">&#125; __attribute__ ((packed));</span><br></pre></td></tr></table></figure>\n\n<p>ceph_msg_footer 为消息的尾部， 附加了一些 crc 校验数据和消息结束标志：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ceph_msg_footer</span> &#123;</span><br><span class=\"line\">\t__le32 front_crc, middle_crc, data_crc;</span><br><span class=\"line\">                                <span class=\"comment\">// 分别对应crc校验码</span></span><br><span class=\"line\">\t__le64  sig;\t\t\t\t<span class=\"comment\">// 消息的64为signature</span></span><br><span class=\"line\">\t__u8 flags;\t\t\t\t\t<span class=\"comment\">// 结束标志</span></span><br><span class=\"line\">&#125; __attribute__ ((packed));</span><br></pre></td></tr></table></figure>\n\n<p>消息带的数据分别保存在 payload、 middle、 data 这三个 bufferlist 中。 payload —般保<br>存 Ceph 操作相关的元数据， middle 目前没有使用到， data—般为读写的数据。</p>\n<h4 id=\"Connection\"><a href=\"#Connection\" class=\"headerlink\" title=\"Connection\"></a>Connection</h4><p>类Connection对应端（port）对端的socket链接的封装。定义于<code>src/msg/Connection.h</code>中，其最重要的接口是可以发送消息：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Connection</span> : <span class=\"keyword\">public</span> RefCountedObjectSafe &#123;</span><br><span class=\"line\">    <span class=\"keyword\">mutable</span> ceph::mutex lock = ceph::<span class=\"built_in\">make_mutex</span>(<span class=\"string\">&quot;Connection::lock&quot;</span>); <span class=\"comment\">// 锁保护Connnection的所有字段</span></span><br><span class=\"line\">    Messenger *msgr;\t\t\t\t\t\t\t\t</span><br><span class=\"line\">    RefCountedPtr priv;\t\t\t\t\t\t\t\t<span class=\"comment\">// 链接的私有数据</span></span><br><span class=\"line\">    <span class=\"type\">int</span> peer_type = <span class=\"number\">-1</span>;\t\t\t\t\t\t\t\t<span class=\"comment\">// 链接的peer类型</span></span><br><span class=\"line\">    <span class=\"type\">int64_t</span> peer_id = <span class=\"number\">-1</span>; \t\t\t\t\t\t\t<span class=\"comment\">// [msgr2 only] the 0 of osd.0, 4567 or client.4567</span></span><br><span class=\"line\">    safe_item_history&lt;<span class=\"type\">entity_addrvec_t</span>&gt; peer_addrs; <span class=\"comment\">// peer的地址（和📕中的类型不一样）</span></span><br><span class=\"line\">    <span class=\"type\">utime_t</span> last_keepalive, last_keepalive_ack;\t\t<span class=\"comment\">// 最后一次发送keepalive和最后一次接收keepalive的ACK的时间</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> anon = <span class=\"literal\">false</span>; \t\t\t\t\t\t\t\t<span class=\"comment\">// &lt; anonymous outgoing connection</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> features = <span class=\"number\">0</span>;\t\t\t\t\t\t\t<span class=\"comment\">// 一些feature的标志位</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">bool</span> is_loopback = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"type\">bool</span> failed = <span class=\"literal\">false</span>; \t\t\t\t\t\t\t<span class=\"comment\">// 当值为true时，该链接为lossy链接已经失效了</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> rx_buffers_version = <span class=\"number\">0</span>;\t\t\t\t\t\t<span class=\"comment\">// 接收缓冲区的版本</span></span><br><span class=\"line\">    std::map&lt;<span class=\"type\">ceph_tid_t</span>, std::pair&lt;ceph::buffer::list, <span class=\"type\">int</span>&gt;&gt; rx_buffers; <span class=\"comment\">// 接收缓冲区</span></span><br><span class=\"line\">    \t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 消息的标识ceph_tid --&gt; (buffer, rx_buffers_version)的映射</span></span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">send_message</span><span class=\"params\">(Message *m)</span> </span>= <span class=\"number\">0</span>;\t\t<span class=\"comment\">// 最重要的功能是发消息的接口</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dispatcher\"><a href=\"#Dispatcher\" class=\"headerlink\" title=\"Dispatcher\"></a>Dispatcher</h4><p>类Dispatcher是消息分发的接口，定义于<code>src/msg/Dispatcher.h</code>中，其分发消息的接口为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">ms_dispatch</span><span class=\"params\">(Message *m)</span> </span>&#123; <span class=\"built_in\">ceph_abort</span>(); &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">ms_fast_dispatch</span><span class=\"params\">(Message *m)</span> </span>&#123; <span class=\"built_in\">ceph_abort</span>(); &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Messenger\"><a href=\"#Messenger\" class=\"headerlink\" title=\"Messenger\"></a>Messenger</h4><p>Messenger 是整个网络抽象模块，定义了网络模块的基本 API 接口。网络模块对外提供的基本功能，就是能在节点之间发送和接受消息。Messenger定义于<code>src/msg/Messenger.h</code>中。</p>\n<p>向一个节点发送消息的命令如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">send_to</span><span class=\"params\">(Message *m, <span class=\"type\">int</span> type, <span class=\"type\">const</span> <span class=\"type\">entity_addrvec_t</span> &amp;addr)</span> </span>= <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<p>注册一个Dispatcher用来分发消息的命令如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add_dispatcher_head</span><span class=\"params\">(Dispatcher *d)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">bool</span> first = dispatchers.<span class=\"built_in\">empty</span>();</span><br><span class=\"line\">        dispatchers.<span class=\"built_in\">push_front</span>(d);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (d-&gt;<span class=\"built_in\">ms_can_fast_dispatch_any</span>())</span><br><span class=\"line\">            fast_dispatchers.<span class=\"built_in\">push_front</span>(d);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first)</span><br><span class=\"line\">            <span class=\"built_in\">ready</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"网络连接的策略\"><a href=\"#网络连接的策略\" class=\"headerlink\" title=\"网络连接的策略\"></a>网络连接的策略</h4><p>Policy定义了Messenger处理Connection的一些策略，位于<code>/src/msg/Policy.h</code>中：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A Policy describes the rules of a Connection. Is there a limit on how</span></span><br><span class=\"line\"><span class=\"comment\"> * much data this Connection can have locally? When the underlying connection</span></span><br><span class=\"line\"><span class=\"comment\"> * experiences an error, does the Connection disappear? Can this Messenger</span></span><br><span class=\"line\"><span class=\"comment\"> * re-establish the underlying connection?</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">ThrottleType</span>&gt; <span class=\"keyword\">struct</span> <span class=\"title class_\">Policy</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">bool</span> lossy; \t<span class=\"comment\">// 如果为 true, 当该连接出现错误时就删除</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> server; \t<span class=\"comment\">// 如果为 true, 为服务端，都是被动连接</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> standby;\t<span class=\"comment\">// 如果为 true, 该连接处于等待状态</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> resetcheck;<span class=\"comment\">// 如果为 true, 该连接出错后重连</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Server: register lossy client connections.</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> register_lossy_clients = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// The net result of this is that a given client can only have one</span></span><br><span class=\"line\">    <span class=\"comment\">// open connection with the server.  If a new connection is made,</span></span><br><span class=\"line\">    <span class=\"comment\">// the old (registered) one is closed by the messenger during the accept</span></span><br><span class=\"line\">    <span class=\"comment\">// process.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  The throttler is used to limit how much data is held by Messages from</span></span><br><span class=\"line\"><span class=\"comment\">     *  the associated Connection(s). When reading in a new Message, the</span></span><br><span class=\"line\"><span class=\"comment\">     * Messenger will call throttler-&gt;throttle() for the size of the new</span></span><br><span class=\"line\"><span class=\"comment\">     * Message.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"comment\">// 该 connection 相关的流控操作</span></span><br><span class=\"line\">    ThrottleType *throttler_bytes;</span><br><span class=\"line\">    ThrottleType *throttler_messages;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 本地端的一些feature标志</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"keyword\">constexpr</span> <span class=\"type\">uint64_t</span> features_supported&#123;CEPH_FEATURES_SUPPORTED_DEFAULT&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 远程端需要的一些 feature 标志</span></span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> features_required;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"网络模块的使用\"><a href=\"#网络模块的使用\" class=\"headerlink\" title=\"网络模块的使用\"></a>网络模块的使用</h4><p>通过下面最基本的服务器和客户端的实例程序，了解如何调用网络通信模块提供的接口来完成收发请求消息的功能。相关代码位于<code>/src/test/msgr/test_msgr.cc</code>中。</p>\n<ol>\n<li><p>Server程序分析：</p>\n<ul>\n<li><p>调用Messenger的函数create创建一个Messenger实例：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">Messenger *server_msgr2 = Messenger::<span class=\"built_in\">create</span>(g_ceph_context, <span class=\"built_in\">string</span>(<span class=\"built_in\">GetParam</span>()), <span class=\"type\">entity_name_t</span>::<span class=\"built_in\">OSD</span>(<span class=\"number\">0</span>), <span class=\"string\">&quot;server&quot;</span>, <span class=\"built_in\">getpid</span>());</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置Messenger属性：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">server_msgr2-&gt;<span class=\"built_in\">set_auth_client</span>(&amp;dummy_auth);</span><br><span class=\"line\">server_msgr2-&gt;<span class=\"built_in\">set_auth_server</span>(&amp;dummy_auth);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对于server，需要bind服务端地址：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">bind_addr.<span class=\"built_in\">parse</span>(<span class=\"string\">&quot;v2:127.0.0.1:16801&quot;</span>);</span><br><span class=\"line\">server_msgr2-&gt;<span class=\"built_in\">bind</span>(bind_addr);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建Dispatcher，并添加到Messenger：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MarkdownDispatcher <span class=\"title\">srv_dispatcher</span><span class=\"params\">(<span class=\"literal\">true</span>)</span></span>;</span><br><span class=\"line\">server_msgr2-&gt;<span class=\"built_in\">add_dispatcher_head</span>(&amp;srv_dispatcher);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动Messenger：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">server_msgr2-&gt;<span class=\"built_in\">start</span>();</span><br><span class=\"line\">server_msgr2-&gt;<span class=\"built_in\">wait</span>();  <span class=\"comment\">// 📕中说本函数必须等start完成才能调用(源代码似乎是等待1000s)</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>Client程序分析</p>\n<ul>\n<li><p>调用Messenger的函数create创建一个Messenger实例：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">client_msgr = Messenger::<span class=\"built_in\">create</span>(g_ceph_context, <span class=\"built_in\">string</span>(<span class=\"built_in\">GetParam</span>()),</span><br><span class=\"line\">                                <span class=\"type\">entity_name_t</span>::<span class=\"built_in\">CLIENT</span>(<span class=\"number\">-1</span>), <span class=\"string\">&quot;client&quot;</span>, <span class=\"built_in\">getpid</span>());</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置相关策略：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">client_msgr-&gt;<span class=\"built_in\">set_default_policy</span>(Messenger::Policy::<span class=\"built_in\">lossy_client</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">client_msgr-&gt;<span class=\"built_in\">set_auth_client</span>(&amp;dummy_auth);</span><br><span class=\"line\">client_msgr-&gt;<span class=\"built_in\">set_auth_server</span>(&amp;dummy_auth);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建Dispatcher并添加，用于接收消息：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MarkdownDispatcher <span class=\"title\">cli_dispatcher</span><span class=\"params\">(<span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">client_msgr-&gt;<span class=\"built_in\">add_dispatcher_head</span>(&amp;cli_dispatcher);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动消息：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">client_msgr-&gt;<span class=\"built_in\">start</span>();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>下面开始发送请求，先获取目标Server的链接：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">ConnectionRef conn2 = client_msgr-&gt;<span class=\"built_in\">connect_to</span>(</span><br><span class=\"line\">            server_msgr2-&gt;<span class=\"built_in\">get_mytype</span>(), server_msgr2-&gt;<span class=\"built_in\">get_myaddrs</span>());</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过 Connection 来发送请求消息 ：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">m = <span class=\"keyword\">new</span> <span class=\"built_in\">MPing</span>();</span><br><span class=\"line\"><span class=\"built_in\">ASSERT_EQ</span>(conn2-&gt;<span class=\"built_in\">send_message</span>(m), <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Async实现\"><a href=\"#Async实现\" class=\"headerlink\" title=\"Async实现\"></a>Async实现</h3><p>📕中讲述的是Simple实现，但现在Async网络通信模型成为了Ceph默认的通信方式。参考了<a href=\"https://blog.csdn.net/bandaoyu/article/details/111962161\">bandaoyu的博客</a>。</p>\n<h4 id=\"基本类\"><a href=\"#基本类\" class=\"headerlink\" title=\"基本类\"></a>基本类</h4><ol>\n<li><p>NetHandler：NetHandler封装了Socket的基本功能。定义于<code>src/msg/async/net_handler.h</code>中。</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> ceph &#123;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NetHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">generic_connect</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">entity_addr_t</span> &amp;addr,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                        <span class=\"type\">const</span> <span class=\"type\">entity_addr_t</span> &amp;bind_addr, <span class=\"type\">bool</span> nonblock)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    CephContext *cct;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">create_socket</span><span class=\"params\">(<span class=\"type\">int</span> domain, <span class=\"type\">bool</span> reuse_addr = <span class=\"literal\">false</span>)</span></span>; <span class=\"comment\">// 创建socket</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">NetHandler</span><span class=\"params\">(CephContext *c)</span> : cct(c) &#123;</span>&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">set_nonblock</span><span class=\"params\">(<span class=\"type\">int</span> sd)</span></span>;\t\t\t\t\t\t\t\t<span class=\"comment\">// 设置socket为非阻塞</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">set_socket_options</span><span class=\"params\">(<span class=\"type\">int</span> sd, <span class=\"type\">bool</span> nodelay, <span class=\"type\">int</span> size)</span></span>; <span class=\"comment\">// 设置socket的选项：nodelay, buffer size</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">connect</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">entity_addr_t</span> &amp;addr, <span class=\"type\">const</span> <span class=\"type\">entity_addr_t</span> &amp;bind_addr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Try to reconnect the socket.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * @return    0         success</span></span><br><span class=\"line\"><span class=\"comment\">     *            &gt; 0       just break, and wait for event</span></span><br><span class=\"line\"><span class=\"comment\">     *            &lt; 0       need to goto fail</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">reconnect</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">entity_addr_t</span> &amp;addr, <span class=\"type\">int</span> sd)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">nonblock_connect</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">entity_addr_t</span> &amp;addr, \t\t<span class=\"comment\">// 非阻塞connect</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                         <span class=\"type\">const</span> <span class=\"type\">entity_addr_t</span> &amp;bind_addr)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_priority</span><span class=\"params\">(<span class=\"type\">int</span> sd, <span class=\"type\">int</span> priority, <span class=\"type\">int</span> domain)</span></span>;\t<span class=\"comment\">// 设置优先级</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&#125; <span class=\"comment\">// namespace ceph</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Worker：Worker类是工作线程的抽象接口，同时添加了listen和connect接口用于服务端和客户端的网络处理。其内部创建一个EventCenter类，该类保存相关处理的事件。定义于<code>src/msg/async/Stack.h</code>中。</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Worker</span> &#123;</span><br><span class=\"line\">\tstd::atomic_uint references;</span><br><span class=\"line\">    EventCenter center;\t<span class=\"comment\">// 事件处理中心，处理该center的所有的事件</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// server端</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">listen</span><span class=\"params\">(<span class=\"type\">entity_addr_t</span> &amp;addr, <span class=\"type\">unsigned</span> addr_slot,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                       <span class=\"type\">const</span> SocketOptions &amp;opts, ServerSocket *)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// client主动连接</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">connect</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">entity_addr_t</span> &amp;addr, <span class=\"type\">const</span> SocketOptions &amp;opts,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                        ConnectedSocket *socket)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>PosixWorker：PosixWorker实现了Worker接口，定义于<code>src/msg/async/PosixStack.h</code>中。</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">PosixWorker</span> : <span class=\"keyword\">public</span> Worker &#123;</span><br><span class=\"line\">    ceph::NetHandler net;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">initialize</span><span class=\"params\">()</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">PosixWorker</span>(CephContext *c, <span class=\"type\">unsigned</span> i) : <span class=\"built_in\">Worker</span>(c, i), <span class=\"built_in\">net</span>(c) &#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 实现了Server端的sock功能：</span></span><br><span class=\"line\">    <span class=\"comment\">// 底层调用NetHandler的功能，实现了socket的bind，listen等操作，最后返回ServerSocket对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">listen</span><span class=\"params\">(<span class=\"type\">entity_addr_t</span> &amp;sa, <span class=\"type\">unsigned</span> addr_slot, <span class=\"type\">const</span> SocketOptions &amp;opt,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">               ServerSocket *socks)</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 实现了主动连接请求。返回ConnectedSocket对象。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">connect</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">entity_addr_t</span> &amp;addr, <span class=\"type\">const</span> SocketOptions &amp;opts,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                ConnectedSocket *socket)</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>NetworkStack：是网络协议栈的接口，定义于<code>src/msg/async/Stack.h</code>中。</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NetworkStack</span> &#123;</span><br><span class=\"line\">    ceph::spinlock pool_spin;\t\t</span><br><span class=\"line\">    <span class=\"type\">bool</span> started = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    CephContext *cct;</span><br><span class=\"line\">    std::vector&lt;Worker *&gt; workers;\t<span class=\"comment\">// worker工作队列</span></span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>PosixNetwork：实现了linux的tcp&#x2F;ip协议接口，定义于<code>src/msg/async/PosixStack.h</code>中。DPDKStack实现了DPDK的接口，RDMAStack实现了IB的接口。</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">PosixNetworkStack</span> : <span class=\"keyword\">public</span> NetworkStack &#123;</span><br><span class=\"line\">    std::vector&lt;std::thread&gt; threads;\t<span class=\"comment\">// 线程池</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> Worker *<span class=\"title\">create_worker</span><span class=\"params\">(CephContext *c, <span class=\"type\">unsigned</span> worker_id)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">PosixWorker</span>(c, worker_id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">PosixNetworkStack</span><span class=\"params\">(CephContext *c)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">spawn_worker</span><span class=\"params\">(std::function&lt;<span class=\"type\">void</span>()&gt; &amp;&amp;func)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        threads.<span class=\"built_in\">emplace_back</span>(std::<span class=\"built_in\">move</span>(func));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">join_worker</span><span class=\"params\">(<span class=\"type\">unsigned</span> i)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">ceph_assert</span>(threads.<span class=\"built_in\">size</span>() &gt; i &amp;&amp; threads[i].<span class=\"built_in\">joinable</span>());</span><br><span class=\"line\">        threads[i].<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p> Worker可以理解为工作者线程，其对应一个thread线程。为了兼容其它协议的设计，对应线程定义在了PosixNetworkStack类里。</p>\n<p> 通过上述分析可知，一个Worker对应一个线程，同时对应一个 事件处理中心EventCenter类。</p>\n</li>\n<li><p>EventDriver：是一个抽象接口，定义了添加事件监听，删除事件监听，获取触发的事件的接口。定义于<code>src/msg/async/Event.h</code>中。</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * EventDriver is a wrap of event mechanisms depends on different OS.</span></span><br><span class=\"line\"><span class=\"comment\"> * For example, Linux will use epoll(2), BSD will use kqueue(2) and select will</span></span><br><span class=\"line\"><span class=\"comment\"> * be used for worst condition.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">EventDriver</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">EventDriver</span>() &#123;&#125; <span class=\"comment\">// we want a virtual destructor!!!</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">init</span><span class=\"params\">(EventCenter *center, <span class=\"type\">int</span> nevent)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">add_event</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">int</span> cur_mask, <span class=\"type\">int</span> mask)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">del_event</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">int</span> cur_mask, <span class=\"type\">int</span> del_mask)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">event_wait</span><span class=\"params\">(std::vector&lt;FiredFileEvent&gt; &amp;fired_events,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                           <span class=\"keyword\">struct</span> timeval *tp)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">resize_events</span><span class=\"params\">(<span class=\"type\">int</span> newsize)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">need_wakeup</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p> 针对不同的IO多路复用机制，实现了不同的类。SelectDriver实现了select的方式；EpollDriver实现了epoll的网络事件处理方式；KqueueDriver是FreeBSD实现kqueue事件处理模型。</p>\n</li>\n<li><p>EventCenter：主要保存事件（包括fileevent，timeevent和外部事件）和处理实践的相关函数。定义于<code>src/msg/async/Event.h</code>中。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">    </span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><a href=\"https://item.jd.com/12072602.html\">Ceph源码分析</a></p>\n","categories":["Ceph"],"tags":["Ceph"]},{"title":"CMU15445-Lab","url":"/2023/03/14/CMU15445-Lab/","content":"<h1 id=\"CMU15445-Fall2022\"><a href=\"#CMU15445-Fall2022\" class=\"headerlink\" title=\"CMU15445 Fall2022\"></a>CMU15445 Fall2022</h1><h2 id=\"HW1-SQL\"><a href=\"#HW1-SQL\" class=\"headerlink\" title=\"HW1 SQL\"></a>HW1 SQL</h2><h3 id=\"sqlite3-基础\"><a href=\"#sqlite3-基础\" class=\"headerlink\" title=\"sqlite3 基础\"></a>sqlite3 基础</h3><ol>\n<li>命令行键入 <code>sqlite3 db_name.db</code> 进入数据库；</li>\n<li><code>.tables</code> 展示检查数据库内容；</li>\n<li><code>.scheme table_name</code> 熟悉表的模式（结构）（包含什么属性、索引，主键和外键是什么）；</li>\n</ol>\n<h3 id=\"实验问题\"><a href=\"#实验问题\" class=\"headerlink\" title=\"实验问题\"></a>实验问题</h3><ol>\n<li>q2：使用 <code>||</code> 拼接两个字符串；</li>\n<li>q3：使用 <code>data(&#39;now&#39;)</code> 返回当前时间，<code>substr()</code> 截取子字符串；</li>\n<li>q6：sql 子查询似乎很慢…</li>\n<li>q9：<a href=\"https://www.sqlitetutorial.net/sqlite-window-functions/sqlite-ntile/\">NTILE()</a>；with 视图；</li>\n<li>q10：<a href=\"https://sqlite.org/lang_with.html\">Recursive CTEs</a>；窗口函数 <code>ROW_NUMBER()</code>；</li>\n</ol>\n<h2 id=\"Project1-Storage-Manger\"><a href=\"#Project1-Storage-Manger\" class=\"headerlink\" title=\"Project1 Storage Manger\"></a>Project1 Storage Manger</h2><h3 id=\"实验问题-1\"><a href=\"#实验问题-1\" class=\"headerlink\" title=\"实验问题\"></a>实验问题</h3><h4 id=\"Extendible-Hash-Table\"><a href=\"#Extendible-Hash-Table\" class=\"headerlink\" title=\"Extendible Hash Table\"></a><a href=\"https://15445.courses.cs.cmu.edu/fall2022/project1/#extendible-hash-table\"><strong>Extendible Hash Table</strong></a></h4><p>这是本实验的第一个任务，实现一个可扩展的哈希表，这里的可扩展只需要考虑根据需求增加哈希表的大小，而不需要考虑缩小或压缩。其中哈希表的 <code>Find(k, v)</code> 和 <code>Remove(k)</code> 接口实现相对比较容易，比较麻烦的是 <code>Insert(k, v)</code> 接口，该接口需要考虑扩展哈希表以及为部分键值对重新分配哈希桶的问题。在此之前需要明确几个概念，</p>\n<ol>\n<li>哈希表的全局深度：整个哈希表用到了多少 bit 将 key 映射到某个哈希桶；</li>\n<li>哈希表中的某个桶的局部深度：该桶用到了多少个 bit 将 key 映射到该桶；</li>\n<li>重排哈希桶：当某个哈希桶满时，将新增哈希桶，并利用更多的 bit 将 key 映射到具体哈希桶中，从而减小哈希冲突（哈希桶的最大大小固定）。</li>\n</ol>\n<p>从全局深度和局部深度的概念中不难得到<code>gloabl_depth &gt;= max(local_depth_1, ...)</code>，因此，当想要插入新数据时，但新数据映射到的哈希桶满了，则</p>\n<ol>\n<li><p>若 <code>gloabl_depth = local_depth</code>，那么很遗憾，即使是使用了 <code>gloabl_depth</code> 个 bit 去映射，这个数据映射到的哈希桶仍然是满的，因此毫无疑问，我们需要利用到更多的 bit，以减弱哈希冲突，即 <code>gloabl_depth++</code>，相应的，哈希桶的数量应该翻倍。在这里引入了一个新问题，那就是我们是否需要立即分配一倍的哈希桶空间？这似乎有点像操作系统中的 <code>COW（Copy On Write）</code> 问题，我们这个时候只是一个哈希桶出现了冲突，而如果直接暴力地分配一倍的哈希桶空间，可能是浪费的，那么，如果不立即分配哈希桶，我们增加的 ”哈希桶“ 该指向哪里呢？试想一下，新增哈希桶是因为现在将利用更多的 bit 来进行映射，那么在没有利用更多 bit 映射之前，这些 key 将映射到哪个地方呢？</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (global_depth_ == <span class=\"built_in\">GetLocalDepthInternal</span>(idx)) &#123;  <span class=\"comment\">// global depth is not enough, need more bit to hash</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; (<span class=\"number\">1</span> &lt;&lt; global_depth_); i++) &#123;</span><br><span class=\"line\">    \tdir_.<span class=\"built_in\">push_back</span>(dir_[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    global_depth_++;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>当前已满的哈希桶局部深度 <code>local_depth</code> 应该 +1，这是因为使用原 <code>local_depth</code> 的 bit 数量映射已经不足以解决该桶的哈希冲突了。</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">dir_[idx]-&gt;<span class=\"built_in\">IncrementDepth</span>();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>最后则是重排哈希桶，此时冲突桶使用到了更多的 bit 来进行映射，此时即触发了一次 <code>COW</code> 操作，需要真正地进行分配新哈希桶空间了，并对冲突桶中已满的所有数据进行重排，以决定哪些留在原桶，哪些从原桶中删除并加入到新桶中。</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> K, <span class=\"keyword\">typename</span> V&gt;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> ExtendibleHashTable&lt;K, V&gt;::<span class=\"built_in\">RedistributeBucket</span>(std::shared_ptr&lt;Bucket&gt; bucket, <span class=\"type\">size_t</span> idx)</span><br><span class=\"line\">    -&gt; std::shared_ptr&lt;Bucket&gt; &#123;</span><br><span class=\"line\">  std::shared_ptr&lt;Bucket&gt; new_bucket = std::<span class=\"built_in\">make_shared</span>&lt;Bucket&gt;(<span class=\"built_in\">Bucket</span>(bucket_size_, bucket-&gt;<span class=\"built_in\">GetDepth</span>()));</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = bucket-&gt;<span class=\"built_in\">GetItems</span>().<span class=\"built_in\">begin</span>(); it != bucket-&gt;<span class=\"built_in\">GetItems</span>().<span class=\"built_in\">end</span>();) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">IndexOf</span>(it-&gt;first, bucket-&gt;<span class=\"built_in\">GetDepth</span>()) == idx) &#123;</span><br><span class=\"line\">      it++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      new_bucket-&gt;<span class=\"built_in\">GetItems</span>().<span class=\"built_in\">push_back</span>(&#123;it-&gt;first, it-&gt;second&#125;);</span><br><span class=\"line\">      it = bucket-&gt;<span class=\"built_in\">GetItems</span>().<span class=\"built_in\">erase</span>(it);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> new_bucket;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 再将指向新桶的指针加入到哈希表 <code>directory</code> 中的正确位置。<strong>值得注意的是，新桶指针可能会覆盖 directory 中的多个位置，具体数量与 <code>gloabl_depth_ - local_depth_</code> 的值有关。</strong></p>\n</li>\n<li><p>此时哈希冲突可能解决了，也可能发生巧合，就是原来已满的哈希桶中的所有数据使用多一 bit 映射时仍然映射到同一位置，因此需要递归进行 <code>Insert(k, v)</code>。</p>\n</li>\n</ol>\n<h4 id=\"LRU-K-Replacement-Policy\"><a href=\"#LRU-K-Replacement-Policy\" class=\"headerlink\" title=\"LRU-K Replacement Policy\"></a><a href=\"https://15445.courses.cs.cmu.edu/fall2022/project1/#lru-k-replacer\"><strong>LRU-K Replacement Policy</strong></a></h4><p>LRU-K 缓存替换算法，问题的关键是设计相关的数据结构。<code>time_map_</code> 之所以需要设置成 <code>multimap</code>，是因为缓存中后向k重用距离为 <code> inf</code> 的对象可能会有多个。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// map frame_id_t to the queue of its k-access timeStamps</span></span><br><span class=\"line\">std::unordered_map&lt;<span class=\"type\">frame_id_t</span>, std::queue&lt;<span class=\"type\">size_t</span>&gt;&gt; refs_map_;</span><br><span class=\"line\"><span class=\"comment\">// real cache set, map frame_id to its iterator in time_map_</span></span><br><span class=\"line\">std::unordered_map&lt;<span class=\"type\">frame_id_t</span>, std::multimap&lt;<span class=\"type\">size_t</span>, <span class=\"type\">frame_id_t</span>&gt;::iterator&gt; cache_map_;</span><br><span class=\"line\"><span class=\"comment\">// multimap timeStamp to frame_id_t, its size should equal cache_map_&#x27;s size</span></span><br><span class=\"line\">std::multimap&lt;<span class=\"type\">size_t</span>, <span class=\"type\">frame_id_t</span>&gt; time_map_;</span><br><span class=\"line\"><span class=\"comment\">// the set contain all evictable frame_id</span></span><br><span class=\"line\">std::unordered_set&lt;<span class=\"type\">frame_id_t</span>&gt; evictable_frame_id_set_;</span><br></pre></td></tr></table></figure>\n\n<p><strong>踩坑：<code>SetEvictable(frame_id_t frame_id, bool set_evictable)</code> 时如果 frame_id 不在缓存中时，直接 return 就可以了。</strong></p>\n<h4 id=\"Buffer-Pool-Manager-Instance\"><a href=\"#Buffer-Pool-Manager-Instance\" class=\"headerlink\" title=\"Buffer Pool Manager Instance\"></a><a href=\"https://15445.courses.cs.cmu.edu/fall2022/project1/#buffer-pool-instance\"><strong>Buffer Pool Manager Instance</strong></a></h4><p>使用前两步完成的扩展哈希表和 LRU-K 缓存替换算法，构建一个缓冲池，相关接口的注释都比较完整。</p>\n<ol>\n<li><code>NewPgImp(page_id_t)</code> 和 <code>FetchPgImp(page_id_t)</code> 接口实现时一定要记得显示地进行 <code>pages_[frame_id].pin_count++</code> 操作，而不仅仅是执行 <code>replacer.SetEvictable(frame_id, false)</code>。</li>\n<li><code>UnpinPgImp</code> 中 is_dirty： <code>pages_[frame_id].is_dirty_ |= is_dirty</code>。</li>\n<li><code>DeletePgImp</code> 需要检查删除的页在 buffer pool 中是否是脏的，如若是脏还需记得刷盘。</li>\n</ol>\n<h3 id=\"感受\"><a href=\"#感受\" class=\"headerlink\" title=\"感受\"></a>感受</h3><p>人麻了，刚写完代码本地测完感觉很好，线上测试狂冒红光，为了过线上测试花了一天。。。</p>\n<p>（很多奇怪的错误可能是由于锁的粒度太细了，用大锁就OK）</p>\n<h2 id=\"Project2-B-Tree-Index\"><a href=\"#Project2-B-Tree-Index\" class=\"headerlink\" title=\"Project2 B+Tree Index\"></a>Project2 B+Tree Index</h2><h3 id=\"实验问题-2\"><a href=\"#实验问题-2\" class=\"headerlink\" title=\"实验问题\"></a>实验问题</h3><h4 id=\"task1：B-Tree-Pages\"><a href=\"#task1：B-Tree-Pages\" class=\"headerlink\" title=\"task1：B+Tree Pages\"></a>task1：B+Tree Pages</h4><ol>\n<li>internal node 和 leaf node 能容纳的 K&#x2F;V 键值对数目不同。internal node 中的 K&#x2F;V 对中的 V 是 page_id，而 leaf node 中的 K&#x2F;V 对中的 V 是 rid（{page_id, slot_num}），同时 leaf node 还包含额外元数据（next_page_id_）；</li>\n<li>B+Tree 非叶子节点的 <code>min_size = (max_size + 1)/2</code>，叶子节点的 <code>min_size = max_size / 2</code>；</li>\n<li>叶子节点插入后的键值对数量达到 max_size_ 则拆分；非叶子节点插入前的 child 数量为 max_size 则拆分；</li>\n</ol>\n<h4 id=\"task2：B-Tree-Data-Structure\"><a href=\"#task2：B-Tree-Data-Structure\" class=\"headerlink\" title=\"task2：B+Tree Data Structure\"></a>task2：B+Tree Data Structure</h4><ol>\n<li><p>Search</p>\n <img src=\"/2023/03/14/CMU15445-Lab/B+Tree_search.jpg\" class=\"\" title=\"B+Tree_search\">\n\n<ul>\n<li><p>需要注意图中的 <code>/*C是叶结点*/</code> 应该和 while 循环是同一缩进；</p>\n</li>\n<li><p>原书中的 非叶子结点 K&#x2F;V 键值对是如下组织的，忽略最后一个 K，因此和实验中忽略第一个 K 的组织方式略有不同，最终会导致取子树 index 时出现加一减一之类的细微区别（寻找非叶子节点中的第一个严格大于查询键的 Key 的索引更简洁）。</p>\n  <img src=\"/2023/03/14/CMU15445-Lab/node.jpg\" class=\"\" title=\"node\"></li>\n</ul>\n</li>\n</ol>\n","categories":["数据库"],"tags":["CMU15445","公开课","数据库"]},{"title":"CMU15445-Lecture","url":"/2023/03/14/CMU15445-Lecture/","content":"<h1 id=\"Lec1-关系模型\"><a href=\"#Lec1-关系模型\" class=\"headerlink\" title=\"Lec1 关系模型\"></a>Lec1 关系模型</h1><ol>\n<li><p>每个关系（Relation）都是一个无序集合，也叫数据库表，集合中每个元素都是一个元组（tuple），每个 tuple 由一组属性构成，这些属性在逻辑上通常有内在联系。</p>\n</li>\n<li><p>主键（primary key）在一个关系中唯一确定一个 tuple。</p>\n</li>\n<li><p>外键（foreign key）唯一确定另一个关系中的一个 tuple。</p>\n</li>\n<li><p>Data Manipulation Language（DML），数据操作语言，比如增删改查。</p>\n</li>\n<li><p>Data Definition Language（DDL），对数据结构进行修改的语言，比如加索引，建表等。</p>\n</li>\n<li><p>在关系模型中查找和查询数据的两种方式，使用哪种方式是具体的实现问题，与 Relational Model 本身无关。</p>\n<ul>\n<li>Procedural：查询命令需要指定 DBMS 执行时的具体查询策略，如关系代数（Relational Algebra），会因操作步骤影响执行效率；</li>\n<li>Non-Procedural：查询命令只需要指定想要查询哪些数据，无需关心幕后的故事，如 SQL。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"Lec2-SQL-进阶\"><a href=\"#Lec2-SQL-进阶\" class=\"headerlink\" title=\"Lec2 SQL 进阶\"></a>Lec2 SQL 进阶</h1><h2 id=\"SQL-历史\"><a href=\"#SQL-历史\" class=\"headerlink\" title=\"SQL 历史\"></a>SQL 历史</h2><p>Structured Query Language，结构化查询语言。</p>\n<h2 id=\"SQL-特性\"><a href=\"#SQL-特性\" class=\"headerlink\" title=\"SQL 特性\"></a>SQL 特性</h2><ol>\n<li>Aggregates：聚类函数，通常可以将查询结果聚合成一个值。<ul>\n<li>AVG(<distinct> col)</li>\n<li>MIN(col)</li>\n<li>MAX(col)</li>\n<li>SUM(<distinct> col)</li>\n<li>COUNT(<distinct> col)</li>\n</ul>\n</li>\n<li>Group By：group by 就是把记录按某种方式分成多组，对每组记录分别做 aggregates 操作。<strong>所有非 aggregates 操作的字段，都必须出现在 group by 语句</strong>。</li>\n<li>Having：基于 aggregation 结果的过滤条件不能写在 WHERE 中，而应放在 HAVING 中，从而对 group by 结果进行进一步筛选。</li>\n<li>Output Control：<ul>\n<li><code>ORDER BY &lt;column*&gt; [ASC|DESC]</code></li>\n<li><code>LIMIT &lt;count&gt; [offset]</code></li>\n</ul>\n</li>\n<li>Common Table Expressions：with 视图（虚拟中间表）。</li>\n<li>Nested Queries：子查询。</li>\n<li>String Operations<ul>\n<li>string match</li>\n<li>string functions</li>\n</ul>\n</li>\n<li>Window Functions：<code>ROW_NUMBER() OVER(&lt;PARTITION BY ...&gt;)</code></li>\n<li>Date&#x2F;Time Operations</li>\n</ol>\n<h1 id=\"Lec3-amp-4-Database-Storage\"><a href=\"#Lec3-amp-4-Database-Storage\" class=\"headerlink\" title=\"Lec3&amp;4 Database Storage\"></a>Lec3&amp;4 Database Storage</h1><h2 id=\"Disk-Manager\"><a href=\"#Disk-Manager\" class=\"headerlink\" title=\"Disk Manager\"></a>Disk Manager</h2><ol>\n<li>为什么不适用 OS 磁盘管理的轮子？主要原因在于，OS 的磁盘管理模块并没有、也不可能会有 DBMS 中的领域知识，因此 DBMS 比 OS 拥有更多、更充分的知识来决定数据移动的时机和数量（OS 只是提供一种普适化的接口，但现在既然具体化到了数据库的场景，那么我们在拥有这种特定场景下的负载特征，自然就可以特制化一些更优秀的策略），具体包括：<ul>\n<li>Flushing dirty pages to disk in the correct order</li>\n<li>Specialized prefetching</li>\n<li>Buffer replacement policy</li>\n<li>Thread&#x2F;process scheduling</li>\n</ul>\n</li>\n<li>DBMS 的磁盘模块主要解决两个问题：<ul>\n<li>How the DBMS represents the database in files on disk（如何使用磁盘文件来表示数据库的数据，比如元数据、索引、数据表等）</li>\n<li>How the DBMS manages its memory and moves data back-and-forth from disk（如何管理数据在内存与磁盘之间的移动）</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"在磁盘文件中表示数据库\"><a href=\"#在磁盘文件中表示数据库\" class=\"headerlink\" title=\"在磁盘文件中表示数据库\"></a>在磁盘文件中表示数据库</h2><h3 id=\"File-Storage\"><a href=\"#File-Storage\" class=\"headerlink\" title=\"File Storage\"></a>File Storage</h3><p>DBMS 通常将自己的所有数据作为一个或多个文件存储在磁盘中，而 OS 只当它们是普通文件，并不知道如何解读这些文件。</p>\n<ol>\n<li>Storage Manager：存储管理器负责维护数据库文件，为读写操作安排合适的调度，从而改善页面的时间和空间局部性</li>\n<li>Database Pages：一个页是固定大小的数据块，每个 page 内部可能存储着 tuples、meta-data、indexes 以及 logs 等等，大多数 DBMS 不会把不同类型数据存储在同一个 page 上。每个 page 带着一个唯一的 id，DBMS 使用一个 indirection layer 将 page id 与数据实际存储的物理位置关联起来。</li>\n<li>Database Heap：有几种方法可以找到 DBMS 想要的页面在磁盘和堆文件中的位置，heap 就是其中一种方式。堆文件是页面的无序集合，以随机顺序存储元组，也就是说我们保存的数据无须按照我们插入时的顺序进行保存。（Linked List 和 Page Directory）。</li>\n</ol>\n<h3 id=\"Page-Layout\"><a href=\"#Page-Layout\" class=\"headerlink\" title=\"Page Layout\"></a>Page Layout</h3><img src=\"/2023/03/14/CMU15445-Lecture/page_layout.jpg\" class=\"\" title=\"page_layout\">\n\n<p>每个 page 被分为两个部分：header 和 data。</p>\n<p>header 中通常包含以下信息：</p>\n<ul>\n<li>Page Size</li>\n<li>Checksum</li>\n<li>DBMS Version</li>\n<li>Transaction Visibility</li>\n<li>Compression Information</li>\n</ul>\n<p>data 中存储真正的数据，包含数据本身和数据的操作日志：Tuple-oriented 和 Log-structured</p>\n<ol>\n<li><p>Tuple-oriented：</p>\n<ul>\n<li><p>Strawman Idea：在 header 中记录 tuple 的个数，然后不断的往下 append 即可。这种方法有两种明显问题，（1）一旦出现删除操作，每次插入就需要遍历一遍，寻找空位，否则就会出现碎片；（2）无法处理变长的数据记录（tuple）</p>\n  <img src=\"/2023/03/14/CMU15445-Lecture/Strawman.jpg\" class=\"\" title=\"Strawman\">\n</li>\n<li><p>Slotted Pages：常用。</p>\n  <img src=\"/2023/03/14/CMU15445-Lecture/slot_page.jpg\" class=\"\" title=\"slot_page\"></li>\n</ul>\n</li>\n<li><p>Log-structured：KV 数据库中好用，因为 KV 数据库中每个键只有一个值，因此只需从日志栈顶往下找第一个 update 就行了，而关系数据库有多个字段，只找到一个 update 可能是不够的。</p>\n<ul>\n<li><p>Slotted-Page Design 存在一些问题：（1）碎片化：删除元组会在页面中留下空白（即时能够迁移也需要额外开销）；（2）无用的磁盘 I&#x2F;O：由于非易失性存储的面向块的特性，整个块需要被读取以获取元组；（3）随机磁盘 I&#x2F;O：磁盘读取器可能必须跳转到 20 个不同的位置才能更新 20 个不同的元组，这非常慢。因此日志结构存储模型仅允许创建新数据而不允许覆盖，解决了上面列出的一些问题。</p>\n</li>\n<li><p>写入速度快，读取速度可能较慢。磁盘写入是顺序的，现有页面是不可变的，导致随机磁盘 I&#x2F;O 减少。</p>\n</li>\n<li><p>为了加快读取，可以创建索引以跳转到日志中的一些特定位置。</p>\n</li>\n<li><p>必要时需要压缩日志。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Tuple-Layout\"><a href=\"#Tuple-Layout\" class=\"headerlink\" title=\"Tuple Layout\"></a>Tuple Layout</h3><p>tuple-oriented 中的数据本身也有别的元信息，比如：</p>\n<ul>\n<li>Visibility information for the DBMS’s concurrency control protocol (i.e., information about which transaction created&#x2F;modified that tuple).</li>\n<li>Bit Map for NULL values. </li>\n<li>Note that the DBMS does not need to store meta-data about the schema of the database here.</li>\n</ul>\n<p>tuple data 中的属性通常按照创建表时指定的顺序存储。</p>\n<img src=\"/2023/03/14/CMU15445-Lecture/tuple_data.jpg\" class=\"\" title=\"tuple_data\">\n\n<p>数据库中的每个元组都分配有一个唯一标识符，最常见的是 <code>page id + (offset or slot)</code>，DBMS 可以创建一个 map，将不同的 tuple 映射到 <code>page id + (offset or slot)</code>。</p>\n<h3 id=\"Tuple-Storage\"><a href=\"#Tuple-Storage\" class=\"headerlink\" title=\"Tuple Storage\"></a>Tuple Storage</h3><p>元组中的数据本质上只是字节数组。由 DBMS 决定如何解释这些字节以导出属性的值。数据表示方案是 DBMS 如何存储这些字节。有五种高级数据类型可以存储在元组中：integers, variable-precision numbers, fixedpoint precision numbers, variable length values, and dates&#x2F;times。</p>\n<p>为了让 DBMS 能够破译元组的内容，它维护了一个内部目录（catelogs）来描述数据库的元数据。这些元数据包括数据库包含的表和列，以及列中的属性的类型以及列的顺序。大多数 DBMS 同样以表的格式将它们的 catelogs 存储在自身内部。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>database is organized in pages;</li>\n<li>different ways to track pages：Heap File Organization…;</li>\n<li>different ways to store pages：Linked List 和 Page Directory;</li>\n<li>different ways to store tuples：Strawman，slotted 和 Log-structured;</li>\n</ol>\n<h1 id=\"Lec5-Storage-Models-amp-Compression\"><a href=\"#Lec5-Storage-Models-amp-Compression\" class=\"headerlink\" title=\"Lec5 Storage Models &amp; Compression\"></a>Lec5 Storage Models &amp; Compression</h1><h2 id=\"Database-Workload\"><a href=\"#Database-Workload\" class=\"headerlink\" title=\"Database Workload\"></a>Database Workload</h2><ol>\n<li>OLTP：Online Transaction Processing，运行速度快、运行时间短、对单个实体进行简单查询。OLTP 工作负载通常会处理更多的写入操作。</li>\n<li>OLAP：Online Analytical Processing，长时间运行、复杂查询、读取数据库中的大部分数据。在 OLAP 工作负载中，数据库系统通过分析大量现有数据，并期望从中获得结论。</li>\n<li>HTAP：Hybrid Transaction + Analytical Processing，尝试在同一个数据库上同时执行 OLTP 和 OLAP 的组合。</li>\n</ol>\n<img src=\"/2023/03/14/CMU15445-Lecture/workloads.jpg\" class=\"\" title=\"workloads\">\n\n<h2 id=\"Storage-Models\"><a href=\"#Storage-Models\" class=\"headerlink\" title=\"Storage Models\"></a>Storage Models</h2><h3 id=\"N-Ary-Storage-Model-NSM\"><a href=\"#N-Ary-Storage-Model-NSM\" class=\"headerlink\" title=\"N-Ary Storage Model (NSM)\"></a>N-Ary Storage Model (NSM)</h3><p>将单个元组的所有属性连续存储在单个页中，这种方法非常适合 OLTP 工作负载，其中请求插入量大且事务倾向于操作单个实体。这是理想的，因为只需要一次读取就可以获取单个元组的所有属性。</p>\n<ol>\n<li>优点<ul>\n<li>快速插入、更新和删除。</li>\n<li>适用于需要整个元组的查询。</li>\n</ul>\n</li>\n<li>缺点：不适合检索表的大部分元组，或者只需要查找小部分的属性。</li>\n</ol>\n<h3 id=\"Decomposition-Storage-Model-DSM\"><a href=\"#Decomposition-Storage-Model-DSM\" class=\"headerlink\" title=\"Decomposition Storage Model (DSM)\"></a>Decomposition Storage Model (DSM)</h3><p>将所有元组的单个属性连续地存储在一个 page 中，这种存储方式特别适用于 OLAP 场景。</p>\n<ol>\n<li>优点<ul>\n<li>减少了浪费的 I&#x2F;O 量，因为 DBMS 只读取该查询所需的数据。</li>\n<li>更好的查询处理和数据压缩支持。</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>由于元组拆分&#x2F;拼接，点查询、插入、更新和删除速度较慢。</li>\n<li>引入新问题：如何跟踪每个元组的不同属性？（1）Fixed-length Offsets：每个属性都是定长的，直接靠 offset 来跟踪（常用），但是不灵活；（2）Embedded Tuple Ids：在每个属性前面都加上 tupleID，但是需要额外的存储开销。</li>\n</ul>\n</li>\n</ol>\n<p><strong>chose right storage model for the ：OLAP（column store） 和 OLTP（row store）。</strong></p>\n<h2 id=\"Database-Compression\"><a href=\"#Database-Compression\" class=\"headerlink\" title=\"Database Compression\"></a>Database Compression</h2><p>压缩对于基于磁盘的 DBMS 来说非常重要，因为磁盘 I&#x2F;O 几乎总是主要的瓶颈；DBMS 可以通过压缩页面以提高每个 I&#x2F;O 操作能够移动的数据有效量，尤其是在只读分析工作负载中。</p>\n<p>如果数据集是完全随机的，那么将没有办法进行压缩。但是，真实世界中的数据集往往存在 key insight，比如：</p>\n<ol>\n<li>数据集往往具有高度偏斜的属性值分布（例如，齐夫分布）</li>\n<li>同一元组的属性之间具有高度相关性（例如，邮政编码和城市，订购日期和发货日期）。</li>\n</ol>\n<p>基于此，我们希望数据库压缩方案具有如下性质：</p>\n<ol>\n<li>必须产生固定长度的值。唯一的例外是存储在单独池中的变长数据，这是因为 DBMS 应该遵循字对齐并能够使用偏移量访问数据。</li>\n<li>允许 DBMS 在查询执行期间尽可能长时间地推迟解压缩（延迟实现）。</li>\n<li>必须是无损方案，因为人们不喜欢丢失数据。任何一种有损压缩都必须在应用程序层级执行。</li>\n</ol>\n<p>在向 DBMS 添加压缩功能之前，我们需要确定要压缩的数据类型，这决定了压缩方案是否可用。压缩粒度有四个级别：</p>\n<ol>\n<li>块级：压缩一个块，这个块中的所有元组隶属于同一张表。</li>\n<li>元组级别：压缩整个元组的内容（仅限 NSM）。</li>\n<li>属性级别：在一个元组中压缩单个属性值。可以针对同一个元组的多个属性。</li>\n<li>列级：为多个元组压缩一个或多个属性值（仅限 DSM）。这允许更复杂的压缩方案。</li>\n</ol>\n<h2 id=\"Naive-Compression\"><a href=\"#Naive-Compression\" class=\"headerlink\" title=\"Naive Compression\"></a>Naive Compression</h2><p>DBMS 使用通用算法（例如 gzip、LZO、LZ4、Snappy、Brotli、Oracle OZIP，Zstd）。尽管 DBMS 可以使用多种压缩算法，但工程师经常选择具有较低压缩率的压缩算法以换取更快的压缩&#x2F;解压缩速度。</p>\n<p>MySQL InnoDB 中有一个使用简单压缩的示例。DBMS 压缩磁盘页、往里面填充 2 的幂次方 KB 并将它们存储到缓冲池中。然而，每次 DBMS 尝试读取数据时，缓冲池中的压缩数据需要解压。</p>\n<p>由于访问数据需要对压缩数据进行解压，这就限制了压缩机制的范围。如果目标是将整个表压缩成一个巨大的块，使用简单的压缩方案<br>这是不可能的，因为每次访问都需要压缩&#x2F;解压缩整个表。因此，对于 MySQL，由于压缩范围有限，它将表分成更小的块。</p>\n<p>另一个问题是这些简单的方案也没有考虑数据的高级特征或语义。这些算法既不关心数据的结构，也不关心查询计划如何访问数据。因此，这放弃了利用 <code>late materialization</code> 的机会，因为这样的话 DBMS 无法知道什么时候可以延迟数据的解压缩。</p>\n<h2 id=\"Columnar-Compression\"><a href=\"#Columnar-Compression\" class=\"headerlink\" title=\"Columnar Compression\"></a>Columnar Compression</h2><h3 id=\"Run-length-Encoding\"><a href=\"#Run-length-Encoding\" class=\"headerlink\" title=\"Run-length Encoding\"></a>Run-length Encoding</h3><h3 id=\"Bit-Packing-Encoding\"><a href=\"#Bit-Packing-Encoding\" class=\"headerlink\" title=\"Bit-Packing Encoding\"></a>Bit-Packing Encoding</h3><h3 id=\"Bitmap-Encoding\"><a href=\"#Bitmap-Encoding\" class=\"headerlink\" title=\"Bitmap Encoding\"></a>Bitmap Encoding</h3><h3 id=\"Delta-Encoding\"><a href=\"#Delta-Encoding\" class=\"headerlink\" title=\"Delta Encoding\"></a>Delta Encoding</h3><h3 id=\"Incremental-Encoding\"><a href=\"#Incremental-Encoding\" class=\"headerlink\" title=\"Incremental Encoding\"></a>Incremental Encoding</h3><h3 id=\"Dictionary-Encoding\"><a href=\"#Dictionary-Encoding\" class=\"headerlink\" title=\"Dictionary Encoding\"></a>Dictionary Encoding</h3><h1 id=\"Lec6-Memory-Management：Buffer-Pools\"><a href=\"#Lec6-Memory-Management：Buffer-Pools\" class=\"headerlink\" title=\"Lec6 Memory Management：Buffer Pools\"></a>Lec6 Memory Management：Buffer Pools</h1><p>DBMS 的磁盘管理模块主要解决两个问题，一个是在 Lec3 &amp; Lec4 中提到的<strong>如何使用磁盘文件来表示数据库的数据（元数据、索引、数据表等）</strong>，另一个就是本节将介绍的<strong>如何管理数据在内存与磁盘之间的移动</strong>。</p>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>DBMS 负责管理其内存并从磁盘来回移动数据。因为，对于大多数情况，数据不能直接在磁盘上操作，任何数据库都必须能够高效地移动以文件形式表示在磁盘上的数据，将它们装入内存，以便可以使用。</p>\n<p>DBMS 面临的问题是将移动数据的延迟降到最低。理想情况下，延迟应该是0，也就是用户使用数据之前，数据已经在内存中了（预取）。而执行引擎不必考虑数据是如何被预取到内存的（内存管理器考虑）。</p>\n<img src=\"/2023/03/14/CMU15445-Lecture/data_move.jpg\" class=\"\" title=\"data_move\">\n\n<p>考虑这个问题的另一种方法是划分为空间和时间控制。</p>\n<ol>\n<li>空间控制策略通过决定将 pages 写到磁盘的哪个位置，使得常常一起使用的 pages 在磁盘的物理距离更近，从而提高 I&#x2F;O 效率。</li>\n<li>时间控制策略通过决定何时将 pages 读入内存，写回磁盘，使得磁盘读写的次数最少，从而提高 I&#x2F;O 效率。</li>\n</ol>\n<h2 id=\"Locks-vs-Latches\"><a href=\"#Locks-vs-Latches\" class=\"headerlink\" title=\"Locks vs. Latches\"></a>Locks vs. Latches</h2><p>在讨论 DBMS 如何保护其内部元素时，我们需要分清 <code>lock</code> 和 <code>latch</code>。</p>\n<p><strong>lock</strong>：lock 是一种更高层级别的逻辑原语，用于保护一个事务中数据库的内容（例如，元组、表、数据库）。事务将在其整个持续时间内持有锁。数据库系统可以向用户公开运行查询时持有哪些 lock。此外，lock 需要能够支持回滚修改。</p>\n<p><strong>latch</strong>：latch 是一种低层级的保护原语，DBMS 在其内部数据结构（例如哈希表、内存区域）中使用以保护临界区。latch 仅在执行操作期间保持。latch 不需要支持回滚修改。</p>\n<img src=\"/2023/03/14/CMU15445-Lecture/lock_latch.png\" class=\"\" title=\"lock_latch\">\n\n<h2 id=\"Buffer-Pool\"><a href=\"#Buffer-Pool\" class=\"headerlink\" title=\"Buffer Pool\"></a>Buffer Pool</h2><p>缓冲池本质上是数据库内部分配的一个大内存区域，用于存储从磁盘获取的页面。</p>\n<p>DBMS 启动时会从 OS 申请一片内存区域，即 Buffer Pool，并将这块区域划分成大小相同的 pages，为了与 disk pages 区别，通常称为 frames。当用户请求一个页面时，DBMS 会先查询缓冲池，如果没有找到页面，则 DBMS 会进一步请求原始的 disk page ，并将该 disk page 复制到 Buffer Pool 的一个 frame 中。</p>\n<h3 id=\"Buffer-Pool-元数据\"><a href=\"#Buffer-Pool-元数据\" class=\"headerlink\" title=\"Buffer Pool 元数据\"></a>Buffer Pool 元数据</h3><p>缓冲池必须维护一定的元数据才能被高效且正确地使用。</p>\n<p>首先，<strong>page table</strong> 是一个内存中的哈希表，用于跟踪当前内存中的页面。它将 page id 映射到缓冲池中的帧位置。</p>\n<p>注意：不要将 page table 和 page directory 混淆，page directory 是将 page id 映射到该页在数据库文件中的位置。对页面目录的所有更改都必须记录在磁盘上，以便 DBMS 可以在重启后找到。</p>\n<p>page table 还维护每个页面的附加元数据、dirty flag 和引用计数器。</p>\n<ol>\n<li>dirty flag 由线程在修改页面时设置。这向存储管理器表明该页面已被修改，必须写回磁盘以持久化。</li>\n<li>引用计数器跟踪当前访问该页面（读取或修改它）的线程数。线程必须在访问页面之前递增计数器，如果页面的计数大于零，则<br> 不允许存储管理器从内存中逐出该页面。</li>\n</ol>\n<h3 id=\"Memory-Allocation-Policies\"><a href=\"#Memory-Allocation-Policies\" class=\"headerlink\" title=\"Memory Allocation Policies\"></a>Memory Allocation Policies</h3><p>缓冲池中的缓存有两种分配策略。</p>\n<p>全局策略：考虑所有活动事务以找到分配内存的最佳决策，以使正在执行的整个工作负载受益（比如最小化全局的磁盘读写次数，类似缓存分配&#x2F;分区策略中的 UCP，相对于动态地为缓冲池分区了）。</p>\n<p>局部策略：它做出的决策将使单个查询或事务运行得更快，即使这对整个工作负载不利。局部策略将帧分配给特定事务而不考虑正在并发进行的其它事务行为（first-in-first-out，对每个事务 ”屡求屡给“，也就相当于没有对缓冲池分区）。</p>\n<p>大多数系统结合使用全局视图和局部视图。</p>\n<h2 id=\"Buffer-Pool-优化\"><a href=\"#Buffer-Pool-优化\" class=\"headerlink\" title=\"Buffer Pool 优化\"></a>Buffer Pool 优化</h2><h3 id=\"Multiple-Buffer-Pools\"><a href=\"#Multiple-Buffer-Pools\" class=\"headerlink\" title=\"Multiple Buffer Pools\"></a>Multiple Buffer Pools</h3><p>DBMS 可以拥有多个缓冲池，比如为每个数据库设置一个缓冲池，为每种页面类型（data page、directory page…）设置一个缓冲池，从而每个缓冲池可以为特定的数据库、页面类型设置局部的缓存策略。与此同时，在处理并发事务时，也可以减少 latch 的争用。</p>\n<h3 id=\"Prefetching\"><a href=\"#Prefetching\" class=\"headerlink\" title=\"Prefetching\"></a>Prefetching</h3><p>缓存预取策略。比如在全局扫描查询中，可以预先将该表接下来将扫描的 page 预取到缓冲池中；将 B+ 树的根节点预取到缓冲池中。</p>\n<h3 id=\"Scan-Sharing-Synchronized-Scans\"><a href=\"#Scan-Sharing-Synchronized-Scans\" class=\"headerlink\" title=\"Scan Sharing (Synchronized Scans)\"></a>Scan Sharing (Synchronized Scans)</h3><p>Scan Sharing 技术主要用在多个查询存在数据共用的情况。当两个查询 A, B 先后发生，B 发现自己有一部分数据与 A 共用，于是先共用 A 的 cursor，等 A 扫完后，再扫描自己还需要的其它数据。</p>\n<h3 id=\"Buffer-Pool-Bypass\"><a href=\"#Buffer-Pool-Bypass\" class=\"headerlink\" title=\"Buffer Pool Bypass\"></a>Buffer Pool Bypass</h3><p>缓存准入策略。全表扫描的 page 可能无需加入缓冲池中，因为它们的时间局部性较差，加入缓存可能会驱逐缓冲池中其它一些局部性较好的页面。因此，DBMS 可能单独分配一块局部内存（Bypass，旁路），在该内存中的写入和处理不影响缓冲池中的其它数据。</p>\n<h2 id=\"OS-Page-Cache\"><a href=\"#OS-Page-Cache\" class=\"headerlink\" title=\"OS Page Cache\"></a>OS Page Cache</h2><p>大部分 disk operations 都是通过系统调用完成，通常系统会维护自身的数据缓存，这会导致一份数据分别在操作系统和 DMBS 中被缓存两次。大多数 DBMS 都会使用 (O_DIRECT) 来告诉 OS 不要缓存这些数据，除了 Postgres。</p>\n<h2 id=\"Buffer-Replacement-Policies\"><a href=\"#Buffer-Replacement-Policies\" class=\"headerlink\" title=\"Buffer Replacement Policies\"></a>Buffer Replacement Policies</h2><p>缓存替换策略。</p>\n<h3 id=\"localization\"><a href=\"#localization\" class=\"headerlink\" title=\"localization\"></a>localization</h3><p>每次事务查询只能驱逐有限的缓冲池页面，或者是拥有一份自己独享的缓冲池区域（缓存分区）。</p>\n<h3 id=\"priority-hints\"><a href=\"#priority-hints\" class=\"headerlink\" title=\"priority hints\"></a>priority hints</h3><p>允许事务告知缓冲池哪些页面非常重要，比如根据页面的具体内容，或者是类似于 B+ 树的根节点。</p>\n<h3 id=\"Dirty-Pages\"><a href=\"#Dirty-Pages\" class=\"headerlink\" title=\"Dirty Pages\"></a>Dirty Pages</h3><p>驱逐一个 dirty page 的成本要高于驱逐一般 page，因为前者需要写 disk，后者可以直接 drop，因此 DBMS 在驱逐缓冲池中的 page 时，需要权衡页面局部性和写回的开销。</p>\n<p>除了直接在 Replacement Policies 中考虑，有的 DBMS 使用 Background Writing 的方式来处理。它们定期扫描 page table，发现 dirty page 就写入 disk，在 Replacement 发生时就无需考虑脏数据带来的问题。</p>\n<h2 id=\"Other-Memory-Pools\"><a href=\"#Other-Memory-Pools\" class=\"headerlink\" title=\"Other Memory Pools\"></a>Other Memory Pools</h2><p>除了存储 tuples 和 indexes，DBMS 还需要 Memory Pools 来存储其它数据，如：</p>\n<ul>\n<li>Sorting + Join Buffers</li>\n<li>Query Caches</li>\n<li>Maintenance Buffers </li>\n<li>Log Buffers</li>\n<li>Dictionary Caches</li>\n</ul>\n<h1 id=\"Lec7-Hash-Tabels\"><a href=\"#Lec7-Hash-Tabels\" class=\"headerlink\" title=\"Lec7 Hash Tabels\"></a>Lec7 Hash Tabels</h1><h2 id=\"Data-Structures\"><a href=\"#Data-Structures\" class=\"headerlink\" title=\"Data Structures\"></a>Data Structures</h2><p>DBMS 为系统内部得不同部分设置了相应的数据结构，比如：</p>\n<ol>\n<li><strong>Internal Meta-Data</strong>：用于跟踪数据库和系统状态的数据，比如 page tables，page directories；</li>\n<li><strong>Core Data Storage</strong>：数据库中元组的基本数据结构；</li>\n<li><strong>Temporary Data Structures</strong>：DBMS 可以在处理查询的过程中临时构建数据结构从而加快执行速度（例如，用于连接的哈希表）；</li>\n<li><strong>Table Indexes</strong>：辅助数据结构，可以用来更容易地找到特定的元组。</li>\n</ol>\n<p>在为 DBMS 实现数据结构时，需要考虑两个主要的设计问题：</p>\n<ol>\n<li>数据组织：我们需要弄清楚内存如何布局，以及支持高效访问，里面存放什么信息。</li>\n<li>并发性：我们还需要考虑如何让多个线程访问数据结构，而不会引起问题。</li>\n</ol>\n<h2 id=\"Hash-Table\"><a href=\"#Hash-Table\" class=\"headerlink\" title=\"Hash Table\"></a>Hash Table</h2><p>哈希表实现了 associative array ADT（Abstract Data Type），将键映射到值。</p>\n<p>Hash Table 主要分为两部分：</p>\n<ol>\n<li><p>Hash Function：</p>\n<ul>\n<li>How to map a large key space into a smaller domain</li>\n<li>Trade-off between <strong>being fast</strong> vs <strong>collision rate</strong></li>\n</ul>\n</li>\n<li><p>Hashing Scheme：</p>\n<ul>\n<li>How to handle key collisions after hashing</li>\n<li>Trade-off between <strong>allocating a large hash table</strong> vs <strong>additional instructions to find&#x2F;insert keys</strong></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Hash-Functions\"><a href=\"#Hash-Functions\" class=\"headerlink\" title=\"Hash Functions\"></a>Hash Functions</h2><p>由于 DBMS 内使用的 Hash Function  并不会暴露在外，因此没必要使用加密哈希函数（例如，SHA-256），我们希望它速度越快，碰撞率越低越好。</p>\n<p>当前最先进的哈希函数是 Facebook XXHash3。</p>\n<h2 id=\"Static-Hashing-Schemes\"><a href=\"#Static-Hashing-Schemes\" class=\"headerlink\" title=\"Static Hashing Schemes\"></a>Static Hashing Schemes</h2><p>静态哈希方案中的哈希表大小固定，这意味着如果哈希表的存储空间用完，就得重建一个更大的哈希表，这样的代价非常昂贵。通常，新哈希表的大小是原始哈希表大小的 2 倍。同时，为了减少发生碰撞时比较的次数，哈希表的槽数会设置成预期元素书的 2 倍，但可惜的是，（1）元素的数量很难提前知道；（2）不同数据通过哈希函数计算得到的键可能会相等；（3）没有一个完美的哈希函数。</p>\n<h3 id=\"Linear-Probe-Hashing\"><a href=\"#Linear-Probe-Hashing\" class=\"headerlink\" title=\"Linear Probe Hashing\"></a>Linear Probe Hashing</h3><h3 id=\"Robin-Hood-Hashing\"><a href=\"#Robin-Hood-Hashing\" class=\"headerlink\" title=\"Robin Hood Hashing\"></a>Robin Hood Hashing</h3><h3 id=\"Cuckoo-Hashing\"><a href=\"#Cuckoo-Hashing\" class=\"headerlink\" title=\"Cuckoo Hashing\"></a>Cuckoo Hashing</h3><h2 id=\"Dynamic-Hashing-Schemes\"><a href=\"#Dynamic-Hashing-Schemes\" class=\"headerlink\" title=\"Dynamic Hashing Schemes\"></a>Dynamic Hashing Schemes</h2><p>动态哈希方案可以按需扩容缩容。</p>\n<h3 id=\"Chained-Hashing\"><a href=\"#Chained-Hashing\" class=\"headerlink\" title=\"Chained Hashing\"></a>Chained Hashing</h3><p>和 Linear Probe Hashing 有点像，只不过 Linear Probe Hashing 中的哈希槽大小是固定的，而 Chained Hashing 的哈希槽大小是可变的，当新插入数据时，创建一个指针指向新数据，并将指针加入到哈希槽的末尾。</p>\n<h3 id=\"Extendible-Hashing\"><a href=\"#Extendible-Hashing\" class=\"headerlink\" title=\"Extendible Hashing\"></a>Extendible Hashing</h3><p>是 project 1 将要实现的一部分，它的基本思想是哈希值的位数慢慢用，一开始数据少时，只是用哈希值的末尾几位，当数据逐渐增多时，哈希冲突越来越剧烈，就逐渐开放使用更多的哈希值位数，同时分配更多的哈希桶来存储数据，进行 rehash 操作，达到扩容的目的。</p>\n<h3 id=\"Linear-Hashing\"><a href=\"#Linear-Hashing\" class=\"headerlink\" title=\"Linear Hashing\"></a>Linear Hashing</h3><h2 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>哈希表提供了 O(1) 的访问效率，因此被大量地应用于 DBMS 的内部实现中。即便如此，她并不适合作为 table index 的数据结构，而 table index 的首选时下节将介绍的 B+ Tree（aka “The Greatest Data Structure of All Time”）。</p>\n<h1 id=\"Lec8-Trees-Indexes\"><a href=\"#Lec8-Trees-Indexes\" class=\"headerlink\" title=\"Lec8 Trees Indexes\"></a>Lec8 Trees Indexes</h1><h2 id=\"Table-Indexes\"><a href=\"#Table-Indexes\" class=\"headerlink\" title=\"Table Indexes\"></a>Table Indexes</h2><p>表索引作为数据库系统内部的数据结构，常常涉及范围扫描查询。有了表索引后，DBMS 在范围查询时，就不需要进行全表扫描，而是可以选择已有的最佳表索引，更快地找到范围内的元组。</p>\n<p>表的内容和索引在逻辑上是同步的。更多的索引可以加快查询速度，但也意味着更大的存储和维护开销。</p>\n<h2 id=\"B-Tree\"><a href=\"#B-Tree\" class=\"headerlink\" title=\"B+Tree\"></a>B+Tree</h2><p>B+Tree 是一种自平衡树，它将数据有序地存储，且在 search、sequential access、insertions 以及 deletions 操作的复杂度上都满足 O(logn)。</p>\n<p>B+Tree 可以看作是 BST (Binary Search Tree) 的衍生结构，它的每个 node 可以有多个孩子，这特别契合 disk-oriented database 的数据存储方式，每个 page 存储一个 node，使得树的结构扁平化，减少获取索引给查询带来的 I&#x2F;O 成本。其基本结构如下图所示：</p>\n<img src=\"/2023/03/14/CMU15445-Lecture/B+Tree.jpg\" class=\"\" title=\"B+Tree\">\n\n<p>通常来说，B+Tree 是一个 M-路 搜索树（M 代表它的最大孩子数量），它有如下性质：</p>\n<ol>\n<li>每个节点最多存储 M-1 个 key，有 M 个 孩子；</li>\n<li>B+Tree 是完全平衡的，即每个叶子节点的深度都一样；</li>\n<li>除了 root 节点，所有其它节点至少处于半满状态，即 M&#x2F;2−1≤ #keys ≤ M−1； </li>\n<li>假设每个非叶子节点中包含 k 个 keys，那么它必然有 k+1 个孩子；</li>\n<li>B+Tree 的叶子节点通过双向链表串联，访问更高效。</li>\n</ol>\n<p>与 B-Tree 相比，B+Tree 仅在叶子节点上存储数据，而 B-Tree 在非叶子节点上也存储数据。</p>\n<h3 id=\"B-Tree-Node\"><a href=\"#B-Tree-Node\" class=\"headerlink\" title=\"B+ Tree Node\"></a>B+ Tree Node</h3><p>B+ Tree 的每个节点包含一个 K&#x2F;V 键值对数组，K 是从表的 attrubute(s) 中提取出来的，即 K 的类型为表的某列的类型；V 值类型取决于节点是否是叶子节点，对于非叶子节点，V 值类型为指向节点的指针，对于叶子节点，V 值类型通常有两种做法：</p>\n<ol>\n<li>Record&#x2F;Tuple Ids：存储指向最终 tuple 的指针；</li>\n<li>Tuple Data：直接将 tuple data 存在 leaf node 中，但这种方式对于 <a href=\"https://docs.oracle.com/cd/E17275_01/html/programmer_reference/am_second.html\">Secondary Indexes</a> 不适用，因为 DBMS 只能将 tuple 数据存储到一个 index 中，否则数据的存储就会出现冗余，同时带来额外的维护成本。</li>\n</ol>\n<p>B+Tree 节点中的 K&#x2F;V 键值对数组基本是按照 K 值排序的，尽管对于 B+Tree 的定义来说不是必需的；从概念上讲，非叶子节点上的 K 只作为标记使用，指导快速查询，但并不意味着这些 K 一定存在于叶子节点上，但是传统上，非叶子节点上的 K 都出现在叶子节点上。</p>\n<h3 id=\"Insertion\"><a href=\"#Insertion\" class=\"headerlink\" title=\"Insertion\"></a>Insertion</h3><ol>\n<li>根据非叶子节点的 K 从树的根部往下找到新 K&#x2F;V 键值对对应的 leaf node，L；</li>\n<li>如果 L 还有空间，则将 K&#x2F;V 键值对插入到 L 中的合适位置，保证 L 中的 K&#x2F;V 键值对仍是有序；否则，需要将 L 均匀分裂成两个节点，同时在 parent node 上新增 entry，新增 entry 的 K 应该是 L 中的中间 K 值，若 parent node 也空间不足，则递归地分裂，直到 root node 为止。</li>\n</ol>\n<h3 id=\"Deletion\"><a href=\"#Deletion\" class=\"headerlink\" title=\"Deletion\"></a>Deletion</h3><p>和在插入后节点满了需要拆分一样，当删除键值对后如果一个节点的大小小于半满时，需要进行合并操作。</p>\n<ol>\n<li>从 root 开始，找到目标 entry 所处的 leaf node, L；</li>\n<li>删除该 entry；</li>\n<li>如果 L 仍然至少处于半满状态，则操作结束；否则先尝试从 siblings 那里拆借 entries，如果失败，则将 L 与相应的 sibling 合并；</li>\n<li>如果合并发生了，则可能需要递归地删除 parent node 中的 entry。</li>\n</ol>\n<p>B+Tree 的 Insert、Delete 过程，可参考<a href=\"https://dichchankinh.com/~galles/visualization/BPlusTree.html\">这里</a>。</p>\n<h3 id=\"Selection-条件\"><a href=\"#Selection-条件\" class=\"headerlink\" title=\"Selection 条件\"></a>Selection 条件</h3><p>因为 B+Tree 是有序的，所以查找很快并且不需要整个键。如果查询条件中提供了键的任何“特征”，DBMS 可以使用 B+Tree 索引。而散列索引需要具体且完整的键，因此无法进行范围查询。</p>\n<h3 id=\"Non-Unique-Indexes\"><a href=\"#Non-Unique-Indexes\" class=\"headerlink\" title=\"Non-Unique Indexes\"></a>Non-Unique Indexes</h3><p>与哈希表一样，B+Tree 也可以处理重复的键。比如存储有相同键的 K&#x2F;V 对，或者是使用关联链表。</p>\n<h3 id=\"Duplicate-Keys\"><a href=\"#Duplicate-Keys\" class=\"headerlink\" title=\"Duplicate Keys\"></a>Duplicate Keys</h3><p>（有点分不清和 Non-Unique Indexes 的关系）</p>\n<h3 id=\"Clustered-Indexes\"><a href=\"#Clustered-Indexes\" class=\"headerlink\" title=\"Clustered Indexes\"></a>Clustered Indexes</h3><p>Clustered Indexes（聚簇索引）规定了 table 本身的物理存储方式，通常即按 primary key 排序存储，因此一个 table 只能建立一个 clustered index。有些 DBMS 对每个 table 的主键都添加聚簇索引，如果该 table 没有 primary key，则 DBMS 会为其自动生成一个。</p>\n<p>table 本身的物理存储按照聚簇索引排序后，通过聚簇索引进行条件查询时，将减少磁盘的读取次数。</p>\n<h3 id=\"Heap-Clustering\"><a href=\"#Heap-Clustering\" class=\"headerlink\" title=\"Heap Clustering\"></a>Heap Clustering</h3><p>有了聚簇索引后，元组在页面中以及页面间按照聚簇索引的规则变得有序。此时访问元组时如若使用了聚类索引（主键），DBMS 就可以直接选择正确的页面，这也就解释了上面说的为什么可以减少磁盘的读取次数。</p>\n<h3 id=\"Index-Scan-Page-Sorting\"><a href=\"#Index-Scan-Page-Sorting\" class=\"headerlink\" title=\"Index Scan Page Sorting\"></a>Index Scan Page Sorting</h3><p>由于直接从非聚集索引中检索元组效率低下（从磁盘中重复读取相同页面），因此 DBMS 可以首先找出它需要的所有元组，然后根据它们的页面 ID 对它们进行排序，再一次从磁盘中读取对应的元组，从而不会重复读取相同的磁盘页面。</p>\n<h2 id=\"B-Tree-Design-Choices\"><a href=\"#B-Tree-Design-Choices\" class=\"headerlink\" title=\"B+Tree Design Choices\"></a>B+Tree Design Choices</h2><h3 id=\"Node-Size\"><a href=\"#Node-Size\" class=\"headerlink\" title=\"Node Size\"></a>Node Size</h3><p>根据存储介质的不同，Node Size 的选择不一样。例如，存储在 HDD 上的节点大小通常在 MB 数量级，以减少查找数据所需的磁盘读取次数，而内存节点大小可能小至 512 字节，以便将整个页面放入 CPU 缓存并减少数据碎片化。这种选择也可以取决于工作负载的类型，因为点查询更喜欢尽可能小的页面以减少不必要的额外信息加载量，而大的顺序 scan 可能更喜欢大页面以减少它需要执行的读取次数。</p>\n<h3 id=\"Merge-Threshold\"><a href=\"#Merge-Threshold\" class=\"headerlink\" title=\"Merge Threshold\"></a>Merge Threshold</h3><p>由于 merge 操作引起的修改较大，有些 DBMS 选择延迟 merge 操作的发生时间，甚至可以利用其它进程来负责周期性地重建 table index。</p>\n<h3 id=\"Variable-Length-Keys\"><a href=\"#Variable-Length-Keys\" class=\"headerlink\" title=\"Variable Length Keys\"></a>Variable Length Keys</h3><p>B+ Tree 中存储的 key 经常是变长的，通常有三种手段来应对：</p>\n<ol>\n<li>Pointers：存储指向 key 的指针；</li>\n<li>Variable-Length Nodes：Node 的大小可以不一致，但这需要精细化的内存管理（几乎没有人这么做）；</li>\n<li>Padding：对 key 的末尾进行 pad 操作，直至 key 最大长度；</li>\n<li>Key Map&#x2F;Indirection：内嵌一个指针数组，数组中的每个元素指向 K&#x2F;V list。</li>\n</ol>\n<h3 id=\"Intra-node-Search\"><a href=\"#Intra-node-Search\" class=\"headerlink\" title=\"Intra-node Search\"></a>Intra-node Search</h3><p>在节点内部搜索，就是在排好序的序列中检索元素，手段通常有：</p>\n<ol>\n<li>Linear Scan：从节点头部向尾部线性搜索；</li>\n<li>Binary Search：二分查找；</li>\n<li>Interpolation：通过 keys 的分布统计信息来估计大概位置进行检索</li>\n</ol>\n<h2 id=\"Optimizations\"><a href=\"#Optimizations\" class=\"headerlink\" title=\"Optimizations\"></a>Optimizations</h2><h3 id=\"Pointer-Swizzling\"><a href=\"#Pointer-Swizzling\" class=\"headerlink\" title=\"Pointer Swizzling\"></a>Pointer Swizzling</h3><p>Node 中的 V 常常使用 page id 来指向其它 Node，这样的话 DBMS 每次需要首先从 page table 中获取对应 page 的 frame_id，然后才能从 buffer pool 获取相应的 node 本身，而如果 page 已经在 buffer pool 中，我们可以直接存储其在 buffer pool 的位置，从而避免查询 page table（常常还需要使用 latch 避免竞争），提高访问效率。</p>\n<h3 id=\"Bulk-Insert\"><a href=\"#Bulk-Insert\" class=\"headerlink\" title=\"Bulk Insert\"></a>Bulk Insert</h3><p>建 B+ Tree 的最快方式是先将 keys 排好序后，再从下往上建树。因此如果有大量插入操作，可以利用这种方式提高效率。</p>\n<h3 id=\"Prefix-Compression\"><a href=\"#Prefix-Compression\" class=\"headerlink\" title=\"Prefix Compression\"></a>Prefix Compression</h3><p>同一个 leaf node 中的 keys 通常有相同的 prefix，为了节省空间，可以只存所有 keys 的不同的 suffix。</p>\n<h3 id=\"Suffix-Truncation\"><a href=\"#Suffix-Truncation\" class=\"headerlink\" title=\"Suffix Truncation\"></a>Suffix Truncation</h3><p>由于非叶子节点只用于引导搜索，因此没有必要在非叶子节点中储存完整的 key，我们可以只存储足够的 prefix 并保证和原来的搜索语义一样即可。</p>\n<h3 id=\"Deduplication\"><a href=\"#Deduplication\" class=\"headerlink\" title=\"Deduplication\"></a>Deduplication</h3><p>Non-unique indexes 可能在节点中存储了多个相同的 K 副本，为了减少冗余，可以替换只存储唯一 K，其中 V 则使用关联列表代替。</p>\n<h1 id=\"Lec9-Index-Concurrency-Control\"><a href=\"#Lec9-Index-Concurrency-Control\" class=\"headerlink\" title=\"Lec9 Index Concurrency Control\"></a>Lec9 Index Concurrency Control</h1><h2 id=\"Latch-Implementations\"><a href=\"#Latch-Implementations\" class=\"headerlink\" title=\"Latch Implementations\"></a>Latch Implementations</h2><ol>\n<li>Blocking OS Mutex：睡眠锁，当该锁被其它线程占用时，当前线程进入睡眠状态，CPU 将调度其它线程。<ul>\n<li>示例：<code>std::mutex</code>；</li>\n<li>优点：使用简单，不需要 DBMS 进行额外编码；</li>\n<li>缺点：由于是操作系统进行调度，代价昂贵（每次锁定&#x2F;解锁大约需要 25 ns）且不可扩展。</li>\n</ul>\n</li>\n<li>Test-and-Set Spin Latch (TAS)：自旋锁，当该锁被其它线程占用时，用户可以自行决定接下来的操作，比如可以选择重试（while 循环）或允许操作系统将当前线程睡眠，因此，该方法给了 DBMS 更多的控制权。<ul>\n<li>示例：<code>std::atomic&lt;T&gt;</code>；</li>\n<li>优点：锁定&#x2F;解锁操作是高效的（因为很多事情交给了用户来做了）；</li>\n<li>缺点：不可扩展且缓存不友好，因为 CAS（compare-and-set）指令将在不同的线程中执行多次。</li>\n</ul>\n</li>\n<li>Reader-Writer Latches：读写锁。<ul>\n<li>示例：<code>std::shared mutex</code>；</li>\n<li>优点：允许并发读；</li>\n<li>缺点：DBMS 需要管理读写队列，避免大量读请求淹没写请求，同时由于额外的元数据，开销比自旋锁搞。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Hash-Table-Latching\"><a href=\"#Hash-Table-Latching\" class=\"headerlink\" title=\"Hash Table Latching\"></a>Hash Table Latching</h2><p>对于静态哈希表，所有线程在遇到哈希冲突时都是自顶向下查看 slot，因此很容易加锁，比如为每个 page 或者 slot 加锁，这样也不会出现死锁的情况（加锁方向一致），当需要重新调整哈希表的大小时，则获取整个哈希表的全局锁即可；</p>\n<ol>\n<li>page 锁：每个页面都有自己的读写锁来保护其全部内容。线程在访问页面之前获取读或写锁。由于一个页面中有多个 slot，这会降低一定的并行度。</li>\n<li>slot 锁：每个 slot 都有一把锁，此时两个线程可以访问同一页中的不同 slot，这增加了存储（每个 slot 有一个锁变量）和计算（一次查找可能涉及很多次加锁&#x2F;解锁操作）开销。</li>\n</ol>\n<p>对于动态哈希表，加锁比较麻烦，但大致思路和上面一样。</p>\n<h2 id=\"B-Tree-Latching\"><a href=\"#B-Tree-Latching\" class=\"headerlink\" title=\"B+Tree Latching\"></a>B+Tree Latching</h2><p>目标：</p>\n<ol>\n<li>允许多线程同时读取和更新 B+Tree；</li>\n<li>同时需要注意两种情形：（1）多个线程同时修改一个节点的内容；（2）一个线程正在遍历树然而另外一个线程正在 split&#x2F;merge 节点；</li>\n</ol>\n<p>举例：T1 想要删除 44，T2 想要查询 41。删除 44 后，DBMS 需要 rebalance，将 H 节点拆分成两个节点。若在拆分前，T2 读取到 D 节点，发现 41 在 H 节点，此时时间片轮转到了 T1，T1 把 D 节点拆分成 H、I 两个节点，同时把 41 转移到 I 节点，之后 CPU 交还给 T2，T2 到 H 节点就找不到 41，如下图所示。</p>\n<img src=\"/2023/03/14/CMU15445-Lecture/B+delete.jpg\" class=\"\" title=\"B+delete\">\n\n<img src=\"/2023/03/14/CMU15445-Lecture/B+rebalance.jpg\" class=\"\" title=\"B+rebalance\">\n\n<img src=\"/2023/03/14/CMU15445-Lecture/B+find.jpg\" class=\"\" title=\"B+find\">\n\n<p>由于 B+Tree 是树形结构，有明确的搜索顺序，因此沿着搜索路径加锁是不错的选择。</p>\n<h3 id=\"Latch-Crabbing-x2F-Coupling\"><a href=\"#Latch-Crabbing-x2F-Coupling\" class=\"headerlink\" title=\"Latch Crabbing&#x2F;Coupling\"></a>Latch Crabbing&#x2F;Coupling</h3><p>它的基本思想是</p>\n<ol>\n<li>获取 parent 的 latch</li>\n<li>获取 child 的 latch</li>\n<li>如果 child “安全”（不会出现 split&#x2F;merge 的情况，它的 parent 节点也就不需要修改），则可以释放 parent 的 latch。</li>\n</ol>\n<h3 id=\"Better-Latching-Algorithm\"><a href=\"#Better-Latching-Algorithm\" class=\"headerlink\" title=\"Better Latching Algorithm\"></a>Better Latching Algorithm</h3><p>在实际应用中，每次更新 B+Tree 都需要获取非叶子节点的写锁是不好的，因为实际的更新只是发生在叶子节点上，而叶子节点大多数情况下是不会影响到上层节点的，尤其是越往上影响到的可能性越小，因此总是持 “悲观” 的想法而获取搜索路径上的的非叶子节点的写锁是不合适的。</p>\n<p>反之，可以采用类似乐观锁的思想，假设 leaf node 是安全（更新操作仅会引起 leaf node 的变化）的，在查询路径上一路获取、释放 read latch，到达 leaf node 时，若操作不会引起 split&#x2F;merge 发生，则只需要在 leaf node 上获取 write latch 然后更新数据，释放 write latch 即可；若操作会引起 split&#x2F;merge 发生，则重新执行一遍，此时在查询路径上一路获取、释放 write latch，即 Latch Crabbing 原始方案。</p>\n<h3 id=\"Leaf-Node-Scans\"><a href=\"#Leaf-Node-Scans\" class=\"headerlink\" title=\"Leaf Node Scans\"></a>Leaf Node Scans</h3><p>以上都是从上往下的访问模式，我们介绍了相关锁的控制；而对于水平方向的访问模式，如果两个线程分别从左往右，从右往左获取写锁，就可能陷入死锁，因此部分 DBMS 在进行范围查询时总是从左往右扫描。</p>\n<h1 id=\"Lec10-Sorting-amp-Aggregations-Algorithms\"><a href=\"#Lec10-Sorting-amp-Aggregations-Algorithms\" class=\"headerlink\" title=\"Lec10 Sorting &amp; Aggregations Algorithms\"></a>Lec10 Sorting &amp; Aggregations Algorithms</h1><p>开始进入 Operator Execution 部分。</p>\n<p>SQL 语句被 DBMS 解释成 Query Plan。</p>\n<img src=\"/2023/03/14/CMU15445-Lecture/query_plan.jpg\" class=\"\" title=\"query_plan\">\n\n<h2 id=\"Sorting\"><a href=\"#Sorting\" class=\"headerlink\" title=\"Sorting\"></a>Sorting</h2><p>Disk-Oriented DBMS 将数据持久化在磁盘中，而不会假设整张表能够完全写入内存中，这也就可能由于数据量过大而无法在内存中完全一次性的排序操作。然而很多时候排序是需要的，比如 <code>ORDER BY</code>，<code>DISTINCT</code>，<code>GROUP BY</code> 和 <code>JOIN</code> 都将需要排好序的数据以便能够快速地执行。</p>\n<p>对于数据量太大而无法放入内存的数据，外部归并排序是一个很好的选择。它是一种分而治之的排序算法，它将数据集分成多个独立的块，然后对它们分别进行排序，并将排序结果写入磁盘，以便下一个阶段使用。</p>\n<h3 id=\"Two-way-Merge-Sort\"><a href=\"#Two-way-Merge-Sort\" class=\"headerlink\" title=\"Two-way Merge Sort\"></a>Two-way Merge Sort</h3><p>该算法的最基本版本是二路归并排序。该算法排序阶段读取每个页面，对它们单独进行排序，并将排序后的结果写回磁盘。然后，在合并阶段，它使用三个缓冲页，其中将两个已排序的页面读取到缓冲页中，并将它们合并到第三个缓冲页面中，每当第三页填满后，它就会写回磁盘并替换为空页。</p>\n<p>复杂度：</p>\n<h3 id=\"General-K-way-Merge-Sort\"><a href=\"#General-K-way-Merge-Sort\" class=\"headerlink\" title=\"General (K-way) Merge Sort\"></a>General (K-way) Merge Sort</h3><p>归并排序的一般版本可以使用三个以上的缓冲页，从而加快排序速度。</p>\n<h3 id=\"Double-Buffering-Optimization\"><a href=\"#Double-Buffering-Optimization\" class=\"headerlink\" title=\"Double Buffering Optimization\"></a>Double Buffering Optimization</h3><p>外部归并排序的一个优化是在后端预取下一阶段的排序块并将其存储在第二个缓冲区，而系统正在处理当前排序块。这减少了 I&#x2F;O 请求的等待时间。但这种优化需要使用多线程，因为预取应该在当前运行的计算发生时发生。</p>\n<h3 id=\"Using-B-Trees\"><a href=\"#Using-B-Trees\" class=\"headerlink\" title=\"Using B+Trees\"></a>Using B+Trees</h3><p>有时 DBMS 使用现有的 B+ 树索引来帮助排序。特别是，如果索引是聚簇索引，数据会按照正确的顺序存储在磁盘中，I&#x2F;O访问<br>将是顺序的，从而 DBMS 可以只遍历B+ 树的叶子结点，不需要进行排序操作。</p>\n<p>另一方面，如果索引是非聚簇的，遍历树几乎总是更糟，因为每条记录可以存储在任何页面中，几乎所有记录访问都需要进行磁盘读取。</p>\n<h2 id=\"Aggregations\"><a href=\"#Aggregations\" class=\"headerlink\" title=\"Aggregations\"></a>Aggregations</h2><p>查询计划中的聚合运算符将一个或多个元组的值折叠为单个标量值。有两种实现聚合的方法：</p>\n<ol>\n<li>排序；</li>\n<li>散列。</li>\n</ol>\n<h3 id=\"Sorting-Aggregation\"><a href=\"#Sorting-Aggregation\" class=\"headerlink\" title=\"Sorting Aggregation\"></a>Sorting Aggregation</h3><p>DBMS 首先根据 GROUP BY Key(s)  对元组进行排序。在内存足够时，可以使用快速排序，如果内存不够，可以使用外部归并排序算法。然后，DBMS 对排序后的数据执行顺序扫描以计算聚合。</p>\n<p>但是，有时候我们并不需要排好序的数据，比如 <code>GROUP BY</code> 和 <code>DISTINCT</code>。在这种场景下 hashing 将更好，它能有效减少排序所需的额外工作。</p>\n<h3 id=\"Hashing-Aggregation\"><a href=\"#Hashing-Aggregation\" class=\"headerlink\" title=\"Hashing Aggregation\"></a>Hashing Aggregation</h3><p>hash 在计算上比 sort 开销更小。 DBMS 通过扫描表填充临时哈希表，对于每条记录，检查是否已经有一个条目，并根据聚合类型执行适当的修改。如果哈希表的大小太大而无法全部装入内存时，DBMS 可以将它写入磁盘。这需要两部操作：</p>\n<ol>\n<li>Partition： Use a hash function h1 to split tuples into partitions on disk based on target hash key。这会将所有匹配的元组放入同一分区；</li>\n<li>ReHash：对于磁盘上的每个分区，将其页面读入内存并基于第二个哈希函数 h2（h1 !&#x3D; h2） 构建一个内存中的哈希表。然后遍历这个临时哈希表的每个桶，将匹配的元组放在一起计算聚合（这假定每个分区都能装入内存）。</li>\n</ol>\n<p>在 ReHash phase 中，存着 (GroupKey→RunningVal) 的键值对，当我们需要向 hash table 中插入新的 tuple 时：</p>\n<ol>\n<li>如果我们发现相应的 GroupKey 已经在内存中，只需要更新 RunningVal 就可以；</li>\n<li>反之，则插入新的 GroupKey 到 RunningVal 的键值对。</li>\n</ol>\n<p>复杂度：</p>\n<h1 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h1><p><a href=\"https://15445.courses.cs.cmu.edu/fall2022/notes/\">官方笔记</a></p>\n<p><a href=\"https://zhenghe.gitbook.io/open-courses/cmu-15-445-645-database-systems/relational-data-model\">公开课笔记</a></p>\n","categories":["数据库"],"tags":["CMU15445","公开课","数据库"]},{"title":"cache replacement policies","url":"/2023/04/01/cache_replace_policies/","content":"<h1 id=\"Abstract\"><a href=\"#Abstract\" class=\"headerlink\" title=\"Abstract\"></a>Abstract</h1><ol>\n<li>本书总结了 CPU 数据缓存的缓存替换策略概况；</li>\n<li>重点讨论算法，因此作者及那个以前的策略分为两大类——粗粒度和细粒度，每类又分为三个子类，以描述解决缓存替换问题的不同方法和每个类别中重要工作的总结；</li>\n<li>探索更多的评价指标，包括不单单局限于缓存缺失率指标、针对多喝设置定制的解决方案、考虑和预取之间的影响、考虑新型内存；</li>\n<li>最后，本书讨论未来工作的趋势和挑战。</li>\n</ol>\n<h1 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h1><ol>\n<li><strong>why cache is important？</strong> 如今移动数据的延迟比执行一条指令的延迟还长，而缓存的存在，可以减少内存延迟和减少内存流量。</li>\n<li>启发式——考虑访问频率、新近度；最近的预测技术。</li>\n<li>如何将缓存替换策略和死块预测结合起来。</li>\n</ol>\n<h1 id=\"A-Taxonomy-of-Cache-Replacement-Policies\"><a href=\"#A-Taxonomy-of-Cache-Replacement-Policies\" class=\"headerlink\" title=\"A Taxonomy of Cache Replacement Policies\"></a>A Taxonomy of Cache Replacement Policies</h1><ol>\n<li><strong>本书为什么这样分类？</strong><ul>\n<li>建立在缓存替换策略解决预测问题的观察之上，其目标是预测是否应允许任何给定对象保留在缓存中；</li>\n<li>预测的决策发生在缓存块中的很多地方，从缓存块插入缓存开始，到它从缓存中淘汰；</li>\n</ul>\n</li>\n<li><strong>本书对缓存替换算法如何分类？</strong><ul>\n<li>首先根据插入决策的粒度分为两类：第一类是<strong>粗粒度</strong>策略，对所有插入对象进行相同的处理，并且仅依据它们在缓存中驻留的表现进行区别对待，例如，对象在缓存中被重用次数增加时优先级会提高；第二类是<strong>细粒度</strong>策略，除了在缓存中驻留的表现会影响优先级外，不同对象在插入时就不一样，这依靠缓存访问模式的历史信息，比如，细粒度策略了解到某个特定指令加载的对象在过去没有被重用就淘汰了，它就会给它在插入时更低的优先级。</li>\n</ul>\n</li>\n<li>缓存替换策略包括：<ul>\n<li>插入策略：How does the replacement policy initialize the replacement state of a new line when it is inserted into the cache?</li>\n<li>提升策略：How does the replacement policy update the replacement state of a line when it hits in the cache?</li>\n<li>衰减策略：How does the replacement policy update the replacement state of a line when a competing line is inserted or promoted?</li>\n<li>驱逐策略：which line does the replacement policy evict to hold new line?</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Coarse-Grained-Policies\"><a href=\"#Coarse-Grained-Policies\" class=\"headerlink\" title=\"Coarse-Grained Policies\"></a>Coarse-Grained Policies</h2><p>粗粒度策略可以认为无“插入策略”，它就区分驻留对象优先级的方式又分为三类：新近度、频率、根据工作负载的变化动态选择不同粗粒度策略的混合策略。</p>\n<h2 id=\"Fine-Grained-Policies\"><a href=\"#Fine-Grained-Policies\" class=\"headerlink\" title=\"Fine-Grained Policies\"></a>Fine-Grained Policies</h2><p>细粒度策略就对象插入时的区分方式分为两类：基于分类（对对象分为缓存友好和缓存不友好两种）、基于重用距离（尝试去预测对象的重用距离）</p>\n<ol>\n<li>分类：通常被认为是最先进的，因为（1）可以利用过去的访问历史为未来做出更正确的决策，（2）可以适应各种缓存访问模式。</li>\n<li>重用距离预测：使用历史信息进行重用距离预测有好有坏，在 4.1 节中进行讨论。</li>\n</ol>\n<h2 id=\"Design-Considerations\"><a href=\"#Design-Considerations\" class=\"headerlink\" title=\"Design Considerations\"></a>Design Considerations</h2><p>缓存替换策略的只要目标是提升缓存命中率，以下这些设计因素有助于实现更高的命中率：</p>\n<ol>\n<li>粒度：</li>\n<li>历史信息：替换策略在做决策时使用了多少历史信息；</li>\n<li>访问模式：替换策略是否适应工作负载。</li>\n</ol>\n<p>在大体趋势上，从左到右是更近时候提出的，使用了更长历史记录并且可以适应更多工作负载的算法，可以看到，细粒度预测非常有优势，它提供了：</p>\n<ol>\n<li>允许细粒度策略仅将缓存空间专用于缓存友好对象；</li>\n<li>允许细粒度策略的每个缓存组动态适应工作负载的变化。</li>\n</ol>\n<img src=\"/2023/04/01/cache_replace_policies/%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB.jpg\" class=\"\" title=\"替换算法分类\">","categories":["Cache"],"tags":["Cache"]}]