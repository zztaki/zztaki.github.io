---
title: CacheSifter（FAST 22）
date: 2023-4-12 17:43:57
description: CacheSifter（FAST 22）论文阅读
tags:
- Cache
- Multi-level
- ML
- 论文阅读
categories:
- Cache
---

**Abstract**

1. 移动应用程序经常将下载文件作为缓存文件维护在本地存储中，从而获得更好的用户体验。但是这些缓存文件占据了移动闪存中的一大部分，对移动设备的性能和寿命有很大影响；
2. 本文提出了 CacheSifter 通用框架，并基于重用行为和内存/存储使用量区分缓存文件；在线将缓存文件分为三类，通过移除大概率不会被重用的文件来减少闪存的写入量；
3. 作者在实际安卓设备上实现了 CacheSifter，并在具有代表性的应用中进行了评估。实验结果表示，依靠 ML 模型，CacheSifter 平均减少了 60% 的缓存文件对闪存的写入量，I/O 密集型写性能改善了 20% 左右。

# Introduction

由于应用的动态性质和整体系统的优化，几乎所有移动应用需要从网络下载文件或数据。而移动设备上的缓存文件可以避免从网络中重新下载数据，从而满足执行延迟的需求。

当前移动设备首先将缓存文件存储在主存中，然后写回闪存（默认在内存中保存 30s）。但是，近年来由于应用程序对数据量的需求增长，缓存文件的数量和大小按指数级增长，降低了移动设备的性能，同时大量缓存文件写回闪存，减少了移动设备的寿命。

值得注意的是，一些缓存文件在其生命周期内只被使用一次，而其它缓存文件在被删除之前可能会被重新访问多次，但是目前的实际系统中，这些缓存文件被同等对待。

现有的一些技术只在 DRAM 上存储缓存文件，减少对闪存的写回，但是，随着应用程序对于缓存文件的需求增长，这会有两个问题：（1）缓存数据在访问频率、生命周期和大小上有很大的区别；（2）在移动设备可用内存不足的情况下，维持无用的缓存文件会因为内存竞争而降低系统的整体性能。本文则根据缓存文件的重用行为管理缓存文件，从而提高系统性能和山存的使用寿命。

本文提出的通用缓存文件管理框架，CacheSifter，使用轻量级机器学习算法将缓存文件动态分类成不同类别，并基于它们的数据访问模式动态地将不同类别的缓存文件放置在 DRAM 或闪存中。基于重用概率，缓存文件被分成三类：Burn-After-Reading (BAR)  文件，Transient 文件和 Long-living 文件。 

# Cache Files in Mobile Systems

**为什么能够对不同缓存文件进行分类？**

1. 实验展示了不同厂商的智能手机、应用程序的**缓存文件平均大小**差异很大；
2. 实验展示了**缓存文件对闪存的写入量**占总写入量的 64%；
3. 实验展示**不同应用程序的写入模式**差异很大（社交软件的缓存文件写入量很大，单机游戏的缓存文件写入量很小）；

**如何对不同缓存文件进行分类？**

1. Burn-After-Reading (BAR)：该类缓存文件只在其生命周期开始阶段有些微重用，没有必要将这类文件写入闪存；
2. Transient：只在创建之后的短期内活跃，有较多重用；
3. Long-living：其它的缓存文件，表现出长期内持续有较多的重用。

**管理缓存文件的挑战**

1. 缓存文件的重用行为可能会随时间变化，因此，在管理时需要实时地适应缓存文件的行为变化；
2. 现有系统都是将所有缓存文件同等对待，然而，对于不同类别的缓存文件，需要使用不同的策略进行管理。

本文的主要目标是改善系统性能和存储寿命；探索应用程序缓存文件的访问模式并考虑基于 DRAM 的内存和基于闪存的移动设备存储在性能和寿命上的特点。

# CacheSifter Design

## Overview

### 设计原则

1. 对应用程序透明：CacheSifter 不能对用户体验造成较大影响，同时，也不能对用户应用程序进行任何更改；
2. 在线分类：分类器需要适应系统状态的动态变化和用户的配置；
3. 自适应内存管理：虽然使用内存保存缓存文件可以实现高效访问，但是使用太多的内存会导致系统性能下降。因此，CacheSifter 应该根据不同的活跃程序自适应调整内存使用量；
4. 适应用户行为的改变：缓存文件的类别可能会发生变化，比如该文件过去是 BAR 文件，但用户行为发生变化后，该文件可能成为 Long-living 文件；
5. 确保删除缓存文件时的安全：在删除 BAR 和 Transient 文件时，应用程序可能正在使用这些文件执行任务，因此，CacheSifter 在删除数据时不能造成应用程序 crash 或用户数据缺失。

### 框架

CacheSifter 处于内核层，能够直接在页缓存上分类缓存文件而不会带来额外的内存开销和数据复制。所有新下载的文件被保存在主存并等待分类。

{% asset_img CacheSifter框架.jpg CacheSifter框架 %}

1. 使用一个轻量级机器学习分类引擎在线将缓存文件分类成上述三类中的一类；
2. 为了更好地利用内存和闪存，丢弃所有 BAR 文件；
3. 将 Transient 文件保存在内存的一个 **LRU-like** 链表中，它包含一个活跃链表和一个不活跃链表。该类文件加入缓存时，插入活跃链表的头部，当离开活跃链表时，如若在活跃链表的存活时间大于阈值，将降级到不活跃链表的头部，否则直接丢弃；当命中不活跃链表的文件时，将提升到活跃链表的头部。当文件从链表中驱逐后，直接丢弃；
4. 将 Long-living 文件保存在内存中的另一个 LRU 链表中，当文件从链表中驱逐且 dirty，则加入闪存；只有在应用程序将该类文件标记为无效后，才从系统中删除。
5. BAR 文件的重新下载，将升级为 “TR，LL” 文件；TR 文件的重新下载，将升级为 LL 文件。

**CacheSifter 带来了三个好处**

1. 避免将 BAR 和 Transient 文件写入闪存，减少了写竞争，延长了闪存寿命，改善了系统性能，节约了存储空间；
2. Transient 文件直接从 DRAM 中访问，改善了该类文件的访问延迟；
3. 在内核层使用轻量级机器学习引擎优化缓存文件管理，仅带来微小开销且对用户程序透明。

## Feature-based Cache Files Management

CacheSifter 的有效性很大程度上依赖分类引擎的准确性，同时，开销也应该尽可能小。

### Lightweight Categorization of Cache Files

**机器学习分类**

本文选择轻量级神经网络 MLP 作为分类模型，而为了进一步降低开销，分类过程分为两步：首先区分是否是 BAR，如若不是，再区分 Transient/Long-living（因为 Long-living 文件无法使用短期信息识别出来）。

选择 K+6 个特征：（1）该文件创建后的前 K 个单位时间点（比如每个时间点 30s）访问的 I/O 大小；（2）读取量、读取次数、写入量、写入次数；（3）文件大小和活跃时间（上次访问时间 - 第一次访问时间）。特别地，为权衡准确率和开销，第一个 MLP 模型需要 K 值小于第二个 MLP 模型。

离线训练两个 MLP 模型。

**模型评价指标**

准确率、召回率、准确率-召回率曲线。

**性能评价指标**

缓存文件对闪存的写入减少量、闪存寿命、读写性能。

**开销分析**

网络开销、内存开销、CPU时间开销。