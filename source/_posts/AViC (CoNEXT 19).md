---
title: AViC (CoNEXT 19)
date: 2023-5-30 18:52:57
description: AViC(CoNEXT 19) 论文阅读
tags:
- Cache
- ML
- 论文阅读
categories:
- Cache
hidden: true
---

本文从准入和驱逐两个角度，同时优化 CDN 场景下的视频缓存。

# Introduction

**视频分发**的背景：视频分发大多采用自适应流（adaptive streaming），通过将每个视频分割成多个固定播放时长的块，然后每个块可以以不同的质量（比特率，bitrates）进行编码，权衡视频的质量和网络带宽。视频发布者选择块的持续时间和比特率参数；客户端设备上的视频播放器从服务器请求连续的块，将检索到的块存储在播放缓存中，播放器运行自适应比特流（adaptive bitrage，ABR）算法以确定下载块的比特率（基于网络状态的评估），兼顾视频质量和卡顿。

# Properties of video delivery

## Chunk size variability

由于视频发布者以多种比特率对块进行了编码，因此客户端可以根据网络质量下载不同比特率的视频块，也就造成了 chunk 大小的可变性。文章中提到蜂窝网络下载的视频块大多在 150KB 到 800KB，而家用带宽下载的块大小可以高达 1800KB。

因此，在进行准入和驱逐决策时，应该考虑块大小。

## Request arrival predictability

客户端播放器请求一个视频块放置在播放缓冲区中，当该视频块即将播放完后，会自动请求下一个视频块，这个间隔略小于视频块的持续时间。

这种发现启发了视频块的预取。

## The prevalence of singletons

作者发现有 40% 的请求块在 12 小时内没有得到重用，这些块进入缓存会挤掉其它流行块从而造成缓存污染（Chunk size variability 更是加剧了这一现象）。（session 的含义还不是很懂，先继续往后看）

# Design

## Eviction

AViC 维护缓存中所有块的**预计下次访问时间**，在需要进行驱逐时，选择最久才会访问的 chunk 进行驱逐。

1. **使用最大堆维护缓存中的块元数据**；

    - 创建：如果请求的块属于当前没有其他块缓存的视频 v，那么就为 v 创建一个新的视频记录 Rv。Rv 通过维护 sessions 记录映射来存储正在进行的视频 sessions 的有关信息。每个 sessions 记录都包含一个 sessionID（一个 32 字节的字符串）、session 请求的最后一个块以及请求该块的时间戳。除了 sessions 记录，Rv 还包含视频 v 的平均请求间隔。

    - 预测及更新：当某个会话请求视频 v 中的块 n 时，将利用上述创建的元数据更新该块的下次预计访问时间，具体的伪代码如下。（更新这块文章写得有点奇怪，我感觉不只是请求块的预计下次访问时间会得到更新，所在视频之后的块应该也需要更新）

        {% asset_img 预测下次访问时间.jpg 预测下次访问时间 %}

2. **周期性预测冷数据**；

    - 如果某个视频 v 中的块很久没有访问了，那么这些块的预计下次访问时间很久没有得到更新，从而会位于最大堆的深处，造成缓存污染。因此，本文额外使用一个 LRU 链表维护所有视频记录，每次请求到来时，都会更新 LRU 链表尾部视频的所有块，就好像这些块被请求了一样，确保过时的视频最终会重新计算其估计值。

3. **针对不同比特率的请求预测**；

    - 上述都是隐性假设只有一种规格的块，但实际上视频使用了多种比特率。

    - 对算法1进行修改，考虑不同比特率的视频块访问次数，利用下式（3）作为请求块的预计下次访问时间。

        {% asset_img 不同比特率预测.jpg 不同比特率预测 %}

## Admission

使用决策树进行二分类，阻止 singleton 的块进入缓存。

1. 选择时间范围（及获取标签）；
    - 额外使用 FIFO 模拟缓存，将完全替换 FIFO 中的全部内容所需时间设置为阈值 T，对于上一小节描述的预测，如果预测时间大于 T，将该块标记为 singleton 作为训练样本。
2. 特征选择；
    - 块大小、块在视频中的索引位置、块比特率；
    - 块所属的{视频的总会话数、视频会话的平均间隔、视频上次的访问时间}；
    - current day 在一周中的索引、current time 在一天24小时中的索引。

## Efficiency Optimizations

1. 在更新请求块 i 的下次预计访问时间时，需要搜索所在视频所有的会话，开销很大；因此，本文额外使用反射的哈希表，大概思想是将视频块索引映射到请求该块的会话列表，此时只需要搜索 i-1, i-2... 块的会话列表是否为空；
2. ...这一部分技术细节很多，推荐看原文。

# Evaluation

1. 针对对象命中率、字节命中率、节省带宽进行了实验评估；
2. 对 AViC 的各个组件进行了消融实验；
3. 时间开销（本文只是将请求到来间隔和服务延迟进行了CDF比较，而不是带宽，不太有说服力，而且也没有和其它方法的服务延迟比较）；和 LRU、GDSF 的内存开销对比；
4. 对一些超参数的敏感性分析。

这一部分很值得学习的地方在于，作者对实验结果进行了详细的原因描述，比如 GDSF 和 LHD 更偏向于驱逐大文件从而导致很多高质量的视频块从缓存中驱逐，然而这种块的流行度往往是很高的；这样做比单纯的展示实验效果更有说服力，也能进一步地展现前面设计中的内涵以及对效果的具体作用。

# 收获

1. 文章的组织架构非常好。在设计部分先简单将设计思想以及驱逐、准入策略描述清楚，再将精细优化独立作为一小节，有助于理解文章的内容的同时，展示出文章扎实的技术功底和低开销；
2. 了解了视频缓存场景的特性，视频连续块在访问模式上存在的联系非常有意思；
3. 文章的不足：场景特殊，通用性可能不足；创新性可能也有点不足，比较偏工程。

