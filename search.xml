<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/10/20/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>测试文章</title>
    <url>/2022/10/20/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>这是一篇测试文章。</p>
<ul>
<li>测试在hexo-blog文件夹下运行hexo clean &amp;&amp; hexo deploy是否可以执行成功。√</li>
<li>测试在hexo-blog文件夹下运行hexo generate &amp;&amp; hexo deploy是否可以执行成功。√</li>
<li>推荐：hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</li>
</ul>
<img src="/2022/10/20/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/%E6%98%9F%E5%A4%9C.jpg" class="" title="图片引用方法一">

]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Ceph源码分析</title>
    <url>/2022/10/22/Ceph%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="《Ceph源码分析》摘要"><a href="#《Ceph源码分析》摘要" class="headerlink" title="《Ceph源码分析》摘要"></a>《Ceph源码分析》摘要</h1><h2 id="Ceph整体结构"><a href="#Ceph整体结构" class="headerlink" title="Ceph整体结构"></a>Ceph整体结构</h2><h3 id="Ceph设计目标"><a href="#Ceph设计目标" class="headerlink" title="Ceph设计目标"></a>Ceph设计目标</h3><ol>
<li>高可用性：Ceph使用数据多副本、纠删码提供数据冗余。</li>
<li>高可扩展性<ul>
<li>集群容量可以伸缩，可以任意添加和删除存储节点、存储设备。</li>
<li>系统性能随集群的增加而线性增加。</li>
</ul>
</li>
<li>大规模：Ceph存储系统的规模可以扩展到成千上万节点。</li>
</ol>
<h3 id="Ceph基本架构图"><a href="#Ceph基本架构图" class="headerlink" title="Ceph基本架构图"></a>Ceph基本架构图</h3><p>Ceph整体架构有三层</p>
<ol>
<li>最底层最核心的RADOS对象存储系统：RADOS（reliable, autonomous, distributed object store）是一个可靠的、自组织的、可自动修复、自我管理的分布式对象存储系统。其内部包括 ceph-osd 后台服务进程和 ceph-mon 监控进程。  </li>
<li>中间层librados库：用于本地或远程通过网络访问RADOS对象存储系统。支持多种语言，如C&#x2F;C++、Java、Python等。</li>
<li>最上层Ceph不同形式的存储接口实现<ul>
<li>块存储结构。</li>
<li>对象存储接口。</li>
<li>文件系统接口。</li>
</ul>
</li>
</ol>
<img src="/2022/10/22/Ceph%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ceph%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E5%9B%BE.png" class="" title="Ceph基本架构图">

<h3 id="Ceph客户端接口"><a href="#Ceph客户端接口" class="headerlink" title="Ceph客户端接口"></a>Ceph客户端接口</h3><h4 id="RBD"><a href="#RBD" class="headerlink" title="RBD"></a>RBD</h4><p>RBD（rados block device）通过 librbd 库对应用提供块存储，主要面向云平台的虚拟机提供虚拟磁盘。传统 SAN 就是块存储，通过 SCSI 或者 FC 接口给应用提供一个独立的 LUN 或者卷。RBD 类似于传统的 SAN 存储，都提供数据块级别的访问。  </p>
<h4 id="CephFS"><a href="#CephFS" class="headerlink" title="CephFS"></a>CephFS</h4><p>CephFS 通过在 RADOS 基础之上增加了 MDS ( Metadata Server) 来提供文件存储。它提供了 libcephfs 库和标准的 P0SIX 文件接口。 CephFS 类似于传统的 NAS 存储，通过 NFS 或者 CIFS 协议提供文件系统或者文件目录服务。</p>
<h4 id="RadosGW"><a href="#RadosGW" class="headerlink" title="RadosGW"></a>RadosGW</h4><p>（看不太明白</p>
<h3 id="RADOS"><a href="#RADOS" class="headerlink" title="RADOS"></a>RADOS</h3><p>RADOS完成了一个存储系统的核心功能，包括以下部分：</p>
<h4 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h4><p>Monitor模块为整个存储集群提供全局的配置和系统信息。</p>
<ol>
<li>它是一个独立部署的daemon进程，通过组成Monitor集群来保证自己的高可用性。</li>
<li>通过Paxos算法实现自己数据的一致性。</li>
<li>提供整个存储系统的节点信息等全局配置信息。</li>
</ol>
<p>Cluster Map保存了系统的全局信息，主要包括：</p>
<ol>
<li>Monitor Map<ul>
<li>包括集群的fsid；</li>
<li>所有Monitor的地址和端口；</li>
<li>current epoch。</li>
</ul>
</li>
<li>OSD Map：所有OSD的列表和OSD的状态等。</li>
<li>MDS Map：所有的MDS的列表和状态。</li>
</ol>
<h4 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h4><p>这里所说的对象是指 RADOS 对象，要和 RadosGW 的 S3 或者 Swift 接口的对象存储区分开来。对象是数据存储的基本单元，一般默认 4MB 大小。下图是一个对象的示意图。</p>
<img src="/2022/10/22/Ceph%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%AF%B9%E8%B1%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="" title="对象示意图">

<p>一个对象由三个部分组成：</p>
<ol>
<li>对象标志ID；</li>
<li>对象的数据，其在本地文件系统中对应一个文件，对象的数据就保存在文件中；</li>
<li>对象的元数据，以key-value形式保存。</li>
</ol>
<h4 id="pool和PG的概念"><a href="#pool和PG的概念" class="headerlink" title="pool和PG的概念"></a>pool和PG的概念</h4><p>pool是一个抽象的存储池。它规定了数据冗余的类型以及对应的副本分布策略（副本类型和纠删码类型等）。一个pool由多个PG构成。</p>
<p>PG（placement group）是一个对象的集合，该集合中的所有对象有相同的放置策略：对象的副本都分布在相同的OSD列表上。一个对象只能属于一个PG，一个PG对应于放置在其上的OSD列表。一个OSD上可以分布多个PG。</p>
<img src="/2022/10/22/Ceph%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/PG%E6%A6%82%E5%BF%B5%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="" title="PG概念示意图">

<ol>
<li>PG1和PG2都属于同一个pool，都是副本类型，且都是两副本；</li>
<li>PG1和PG2里包含许多对象，PG1 上的所有对象，主从副本分布在 0SD1 和<br> 0SD2 上，PG2 上的所有对象的主从副本分布在0SD2 和 OSD3 上；</li>
<li>一个对象只能属于一个PG，一个PG包含多个对象；</li>
<li>一个 PG 的副本分布在对应的 OSD 列表中。在一个 OSD 上可以分布多个 PG。示例中 PG1 和 PG2 的从副本都分布在 0SD2 上。</li>
</ol>
<h4 id="对象寻址过程"><a href="#对象寻址过程" class="headerlink" title="对象寻址过程"></a>对象寻址过程</h4><p>1</p>
<h4 id="数据读写过程"><a href="#数据读写过程" class="headerlink" title="数据读写过程"></a>数据读写过程</h4><p>1</p>
<h4 id="数据均衡"><a href="#数据均衡" class="headerlink" title="数据均衡"></a>数据均衡</h4><p>1</p>
<h4 id="Peering"><a href="#Peering" class="headerlink" title="Peering"></a>Peering</h4><p>1</p>
<h4 id="Recovery和Backfill"><a href="#Recovery和Backfill" class="headerlink" title="Recovery和Backfill"></a>Recovery和Backfill</h4><p>1</p>
<h4 id="纠删码"><a href="#纠删码" class="headerlink" title="纠删码"></a>纠删码</h4><p>1</p>
<h4 id="快照和克隆"><a href="#快照和克隆" class="headerlink" title="快照和克隆"></a>快照和克隆</h4><p>1</p>
<h4 id="Cache-Tier"><a href="#Cache-Tier" class="headerlink" title="Cache Tier"></a>Cache Tier</h4><p>1</p>
<h4 id="Scrub"><a href="#Scrub" class="headerlink" title="Scrub"></a>Scrub</h4><p>1</p>
<h4 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h4><p>1</p>
<h2 id="Ceph通用模块"><a href="#Ceph通用模块" class="headerlink" title="Ceph通用模块"></a>Ceph通用模块</h2><p>Ceph源代码通用库中的一些关键而又复杂的数据结构。</p>
<ol>
<li>Object和Buffer普遍使用；</li>
<li>线程池ThreadPool可以提高消息处理的并发能力；</li>
<li>Finisher提供异步操作时来执行回调函数；</li>
<li>Throttle在系统的各个模块各个环节都能看到，用来限制系统的请求，避免瞬时大量请求对系统的冲击；</li>
<li>SafteTimer提供定时器，为超时和定时任务等提供了相应的机制。</li>
</ol>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>对象Object默认为4MB大小的数据块。一个对象对应本地文件系统中的一个文件。在代码实现中，有object、sobject、hobject、ghobject等不同的类。大多位于<code>src/include/object.h</code>中。</p>
<h4 id="object-t"><a href="#object-t" class="headerlink" title="object_t"></a>object_t</h4><p>object_t对应本地文件系统中的一个文件，name就是对象名。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">object_t</span>&#123;</span><br><span class="line">	string name;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sobject-t"><a href="#sobject-t" class="headerlink" title="sobject_t"></a>sobject_t</h4><p>sobject_t在object_t之上增加了snapshot信息，用于标识是否是快照对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sobject_t</span> &#123;</span><br><span class="line">	<span class="type">object_t</span> oid;</span><br><span class="line">	<span class="type">snapid_t</span> snap; <span class="comment">// 快照对象的对应的快照序号；若不是快照对象（也就是head对象），snap字段则为CEPH_NOSNAP值</span></span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="hobject-t"><a href="#hobject-t" class="headerlink" title="hobject_t"></a>hobject_t</h4><p>hobject_t 是 hash object 的缩写。位于<code>src\common\hobject.h</code>中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">hobject_t</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">object_t</span> oid;</span><br><span class="line">    <span class="type">snapid_t</span> snap;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">uint32_t</span> hash; <span class="comment">// hash和key不能同时设置，hash值一般设为pg的id值</span></span><br><span class="line">    <span class="type">bool</span> max;</span><br><span class="line">    <span class="type">uint32_t</span> nibblewise_key_cache;</span><br><span class="line">    <span class="type">uint32_t</span> hash_reverse_bits;</span><br><span class="line">	......</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int64_t</span> pool; <span class="comment">// 所在pool的id</span></span><br><span class="line">    std::string nspace; <span class="comment">// 一般为空，用于标识特殊的对象</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::string key; <span class="comment">// 对象的特殊标记</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ghobject-t"><a href="#ghobject-t" class="headerlink" title="ghobject_t"></a>ghobject_t</h4><p>在hobject_t基础上，添加generation和shard_id字段，用于纠删码模式下的PG。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ghobject_t</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">gen_t</span> NO_GEN = UINT64_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> max = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">shard_id_t</span> shard_id = <span class="type">shard_id_t</span>::NO_SHARD; <span class="comment">// 标识对象所在的OSD在纠删码类型的PG中的序号；如果在副本类型的PG中，那么字段就设置为NO_SHARD(-1)</span></span><br><span class="line">    <span class="type">hobject_t</span> hobj;</span><br><span class="line">    <span class="type">gen_t</span> generation = NO_GEN; <span class="comment">// 记录对象的版本号。当PG为纠删码类型时，写操作需要区别写前后两个版本的object，此时该字段保存对象的上一个版本，当写失败时，可以rollback到上一个版本</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>buffer是一个命名空间，里面定义了buffer相关的数据结构。</p>
<h4 id="buffer-raw"><a href="#buffer-raw" class="headerlink" title="buffer::raw"></a>buffer::raw</h4><p>位于<code>src/include/buffer_raw.h</code>中，是一个基类，其子类完成buffer数据空间的分配。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ceph</span>::buffer::v15_2_0::raw&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">char</span> *data;  <span class="comment">// 数据指针</span></span><br><span class="line">	<span class="type">unsigned</span> len; <span class="comment">// 数据长度</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ceph::atomic&lt;<span class="type">unsigned</span>&gt; nref&#123;<span class="number">0</span>&#125;; <span class="comment">// 引用计数</span></span><br><span class="line">	std::aligned_storage&lt;<span class="built_in">sizeof</span>(ptr_node),<span class="built_in">alignof</span>(ptr_node)&gt;::type bptr_storage; <span class="comment">// 大小为sizeof(ptr_node)，alignof(ptr_node)对齐的类型。用于ptr_node的构造(new placement方式)，实际并未使用</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 指定数据段的校验值</span></span><br><span class="line">    std::pair&lt;<span class="type">size_t</span>, <span class="type">size_t</span>&gt; last_crc_offset &#123;std::numeric_limits&lt;<span class="type">size_t</span>&gt;::<span class="built_in">max</span>(), std::numeric_limits&lt;<span class="type">size_t</span>&gt;::<span class="built_in">max</span>()&#125;;</span><br><span class="line">    std::pair&lt;<span class="type">uint32_t</span>, <span class="type">uint32_t</span>&gt; last_crc_val;</span><br><span class="line">	<span class="keyword">mutable</span> ceph::spinlock crc_spinlock; </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下列类继承了<code>buffer::raw</code>，实现了data对应内存空间的申请，定义于<code>src/common/buffer.cc</code>中：</p>
<ol>
<li>class raw_combined：分配的对象于data buffer分配在一个buffer上，data处于buffer的开头，object为buffer尾；</li>
<li>class raw_malloc：实现了用 malloc 函数分配内存空间的功能；</li>
<li>class buffer::raw_posix_aligned：调用了函数 posix_memaligii 来申请内存地址对齐<br> 的内存空间；</li>
<li>class raw_static：data buffer使用static buffer；</li>
<li>class buffer::raw_hack_aligned：在系统不支持内存对齐申请的情况下自己实现<br> 了内存地址的对齐；</li>
<li>class buffer::raw_char：使用了 C++ 的 new 操作符来申请内存空间； </li>
<li>class buffer::raw_claimed_char：不负责释放资源，因此可以是局部变量。针对new创建的buffer，则需手动显示释放；</li>
<li>class buffer::raw_claim_buffer：接收自定义删除器。</li>
</ol>
<h4 id="buffer-ptr"><a href="#buffer-ptr" class="headerlink" title="buffer::ptr"></a>buffer::ptr</h4><p>是对于buffer::raw的一个部分数据段，定义于<code>src/include/buffer.h</code>中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CEPH_BUFFER_API</span> ptr&#123;</span><br><span class="line">    raw *_raw;</span><br><span class="line">    <span class="type">unsigned</span> _off, _len; <span class="comment">// 起始偏移量，长度</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/22/Ceph%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/raw%E5%92%8Cptr%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="" title="raw和ptr示意图">

<h4 id="buffer-list"><a href="#buffer-list" class="headerlink" title="buffer::list"></a>buffer::list</h4><p>是多个buffer::ptr的列表，也就是多个内存数据段的列表，定义于<code>src/include/buffer.h</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CEPH_BUFFER_API</span> list&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">buffers_t</span>&#123; <span class="comment">// 底层单链表实现</span></span><br><span class="line">		ptr_hook _root;</span><br><span class="line">		ptr_hook *_tail;</span><br><span class="line">		......</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 添加到头部</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(reference item)</span> </span>&#123;</span><br><span class="line">            item.next = _root.next;</span><br><span class="line">            _root.next = &amp;item;</span><br><span class="line">            _tail = _tail == &amp;_root ? &amp;item : _tail;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">buffers_t</span> _buffers; <span class="comment">// 自己的私有bits</span></span><br><span class="line">	<span class="type">unsigned</span> _len;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（list结构大改，还需要仔细阅读原书和源码</strong></p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>ThreadPool定义于<code>src/common/WorkQueue.h</code>中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> : <span class="keyword">public</span> <span class="type">md_config_obs_t</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	CephContext *cct;</span><br><span class="line">  	std::string name; 						<span class="comment">// 线程名？</span></span><br><span class="line">  	std::string thread_name; </span><br><span class="line">  	std::string lockname; 					<span class="comment">// 锁名</span></span><br><span class="line">  	ceph::mutex _lock; 						<span class="comment">// 线程互斥锁，也是工作队列访问互斥的锁</span></span><br><span class="line">  	ceph::condition_variable _cond;			<span class="comment">// 锁对应的条件变量</span></span><br><span class="line">  	<span class="type">bool</span> _stop; 							<span class="comment">// 线程池是否停止工作的标志</span></span><br><span class="line">  	<span class="type">int</span> _pause; 							<span class="comment">// 暂停中止线程池的标志</span></span><br><span class="line">  	<span class="type">int</span> _draining;</span><br><span class="line"> 	ceph::condition_variable _wait_cond;</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;WorkQueue_*&gt; work_queues; 	<span class="comment">// 工作队列[集和]</span></span><br><span class="line">    <span class="type">int</span> next_work_queue = <span class="number">0</span>;				<span class="comment">// 下一次访问的工作队列</span></span><br><span class="line">    </span><br><span class="line">    std::set&lt;WorkThread*&gt; _threads;			<span class="comment">// 线程池中的工作线程</span></span><br><span class="line">    std::list&lt;WorkThread*&gt; _old_threads;  	<span class="comment">// 等待进joined操作的线程</span></span><br><span class="line">  	<span class="type">int</span> processing;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般情况下，一个工作队列对应一个类型的后台处理任务，一个线程池对应一个工作队列，专门用于处理该类型的任务。如果是后台任务，又不紧急，就可以将多个工作队列放置到一个线程池中，该线程池可以处理不同类型的任务。</p>
<p>线程池的实现主要包括：</p>
<ol>
<li>线程池的启动过程；</li>
<li>线程池对应的工作队列管理；</li>
<li>线程池对应的执行函数如何执行任务。</li>
</ol>
<h4 id="线程池的启动"><a href="#线程池的启动" class="headerlink" title="线程池的启动"></a>线程池的启动</h4><p>ThreadPool::start()用来启动线程池，其在加锁的情况下，调用函数 start_threads，该函数检査当前线程数，如果小于配置的线程池，就创建新的工作线程。定义于<code>src/common/WorkQueue.cc</code>。</p>
<h4 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h4><p>工作队列（WorkQueue) 定义了线程池要处理的任务。</p>
<ol>
<li>任务类型在模板参数中指定；</li>
<li>在构造函数里，就把自己加入到线程池的工作队列集合中；</li>
<li>WorkQueue实现了部分功能：进队列、出队列、加锁；</li>
<li>部分功能需要使用者定义，如定义保存任务的容器，添加和删除的方法，以及如何处理任务的方法。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkQueue</span> : <span class="keyword">public</span> WorkQueue_ &#123;</span><br><span class="line">    ThreadPool *pool;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Add a work item to the queue.</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">bool</span> _enqueue(T *) = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Dequeue a previously submitted work item.</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> _dequeue(T *) = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Dequeue a work item and return the original submitted pointer.</span></span><br><span class="line">    <span class="keyword">virtual</span> T *_dequeue() = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// Process a work item. Called from the worker threads.</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> _process(T *t, TPHandle &amp;) = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">WorkQueue</span>(std::string n,</span><br><span class="line">	    	ceph::timespan ti, ceph::timespan sti,</span><br><span class="line">	    	ThreadPool* p)</span><br><span class="line">      		: <span class="built_in">WorkQueue_</span>(std::<span class="built_in">move</span>(n), ti, sti), <span class="built_in">pool</span>(p) &#123;</span><br><span class="line">      	pool-&gt;<span class="built_in">add_work_queue</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">queue</span><span class="params">(T *item)</span> </span>&#123; <span class="comment">// 进队列</span></span><br><span class="line">     	pool-&gt;_lock.<span class="built_in">lock</span>();</span><br><span class="line">     	<span class="type">bool</span> r = _enqueue(item);</span><br><span class="line">     	pool-&gt;_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">     	pool-&gt;_lock.<span class="built_in">unlock</span>();</span><br><span class="line">    	<span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dequeue</span><span class="params">(T *item)</span> </span>&#123; <span class="comment">// 出队列</span></span><br><span class="line">      	pool-&gt;_lock.<span class="built_in">lock</span>();</span><br><span class="line">      	_dequeue(item);</span><br><span class="line">      	pool-&gt;_lock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	pool-&gt;_lock.<span class="built_in">lock</span>();</span><br><span class="line">      	_clear();</span><br><span class="line">      	pool-&gt;_lock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; pool-&gt;<span class="built_in">lock</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; pool-&gt;<span class="built_in">unlock</span>(); &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程池的执行函数"><a href="#线程池的执行函数" class="headerlink" title="线程池的执行函数"></a>线程池的执行函数</h4><p>ThreadPool::worker定义于<code>src/common/WorkQueue.cc</code>中。</p>
<ol>
<li>首先检查_stop标志，确保线程池没有关闭；</li>
<li>调用函数join_old_threads把旧的工作线程释放掉。检査如果线程数量大于配置的数量 _num_threads，就把当前线程从线程集合中删除，并加入_old_threads队列中，并退<br> 出循环；</li>
<li>如果线程池没有中止（_pause）且work_queues不为空，就从next_work_queue开始，边理每一个工作队列，如果工作会裂不为空，就取出一个item，调用工作队列的处理函数做处理。</li>
</ol>
<h4 id="超时检查"><a href="#超时检查" class="headerlink" title="超时检查"></a>超时检查</h4><p>TPHandle是一个有意思的事情，定义于<code>src/common/WorkerQueue.h</code>中。每次线程函数执行时，都会设置一个 grace 超时时间，当线程执行超过该时间，就认为是 unhealthy 的状态。当执行时间超过 suicide_grace 时，OSD 就会产生断言而导致自杀，代码如下：  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span>::TPHandle : <span class="keyword">public</span> HBHandle &#123;</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span>;</span><br><span class="line">        CephContext *cct;				</span><br><span class="line">        ceph::heartbeat_handle_d *hb;	<span class="comment">// 心跳</span></span><br><span class="line">        ceph::timespan grace;			<span class="comment">// 超时</span></span><br><span class="line">        ceph::timespan suicide_grace;	<span class="comment">// 自杀的超时时间</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">TPHandle</span>(CephContext *cct, ceph::heartbeat_handle_d *hb,</span><br><span class="line">                 ceph::timespan grace, ceph::timespan suicide_grace)</span><br><span class="line">            : <span class="built_in">cct</span>(cct), <span class="built_in">hb</span>(hb), <span class="built_in">grace</span>(grace), <span class="built_in">suicide_grace</span>(suicide_grace) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">reset_tp_timeout</span><span class="params">()</span> <span class="keyword">override</span> <span class="keyword">final</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">suspend_tp_timeout</span><span class="params">()</span> <span class="keyword">override</span> <span class="keyword">final</span></span>;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="ShardedThreadPool"><a href="#ShardedThreadPool" class="headerlink" title="ShardedThreadPool"></a>ShardedThreadPool</h4><p>ThreadPool 实现的线程池，其每个线程都有机会处理工作队列的任意一个任务。这就会导致一个问题：如果任务之间有互斥性，那么正在处理该任务的两个线程有一个必须等待另一个处理完成后才能处理，从而导致线程的阻塞，性能下降。</p>
<p>具体如何实现 Shard 方式，还需要使用者自己去实现。其基本的思想就是：每个线程对应一个任务队列，所有需要顺序执行的任务都放在同一个线程的任务队列里，全部由该线程执行。 定义于<code>src/common/WorkerQueue.h</code>中 </p>
<h3 id="Finisher"><a href="#Finisher" class="headerlink" title="Finisher"></a>Finisher</h3><p>类Finisher用来完成回调函数Context的执行，其内部有一个FinisherThread线程来用于执行Context回调函数。定义于<code>src/common/Finisher.h</code>中。</p>
<h3 id="Throttle"><a href="#Throttle" class="headerlink" title="Throttle"></a>Throttle</h3><p>类Throttle用来限制消费的资源数量（也常称为槽位 “slot”），当请求的 slot 数量达到max值时，请求就会被阻塞，直到有新的槽位释放出来，定义于<code>src/common/Throttle.h</code>中，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Throttle</span> <span class="keyword">final</span> : <span class="keyword">public</span> ThrottleInterface &#123;</span><br><span class="line">  	CephContext *cct;</span><br><span class="line">  	<span class="type">const</span> std::string name;</span><br><span class="line">  	PerfCountersRef logger;</span><br><span class="line">  	std::atomic&lt;<span class="type">int64_t</span>&gt; count = &#123; <span class="number">0</span> &#125;, max = &#123; <span class="number">0</span> &#125;;  	<span class="comment">// 当前占用的slot数量和slot数量的最大值</span></span><br><span class="line">  	std::mutex lock;									<span class="comment">// 等待的锁</span></span><br><span class="line">  	std::list&lt;std::condition_variable&gt; conds;			<span class="comment">// 等待的条件变量</span></span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">get</span><span class="params">(<span class="type">int64_t</span> c = <span class="number">1</span>, <span class="type">int64_t</span> m = <span class="number">0</span>)</span></span>;				<span class="comment">// 获取c个slot，如果m不为0值，则将max设置为m的值；成功获取c个slot后，就返回true，否则阻塞等待</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">get_or_fail</span><span class="params">(<span class="type">int64_t</span> c = <span class="number">1</span>)</span></span>;					<span class="comment">// 当获取不到c个slot时，直接返回false，不阻塞等待</span></span><br><span class="line">    <span class="function"><span class="type">int64_t</span> <span class="title">put</span><span class="params">(<span class="type">int64_t</span> c = <span class="number">1</span>)</span> <span class="keyword">override</span></span>;				<span class="comment">// 释放c个slot资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SafeTimer"><a href="#SafeTimer" class="headerlink" title="SafeTimer"></a>SafeTimer</h3><p>类SafeTimer实现了定时器的功能，定义于<code>src/common/Timer.h</code>中，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Mutex</span>&gt; <span class="keyword">class</span> <span class="title class_">CommonSafeTimer</span> &#123;</span><br><span class="line">    CephContext *cct;</span><br><span class="line">    Mutex &amp;lock;</span><br><span class="line">    std::condition_variable_any cond;</span><br><span class="line">    <span class="type">bool</span> safe_callbacks;							<span class="comment">// 是否是safe_callbacks</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">CommonSafeTimerThread</span>&lt;Mutex&gt;;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CommonSafeTimerThread</span>&lt;Mutex&gt; *thread;		<span class="comment">// 定时器执行线程</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">using</span> <span class="type">clock_t</span> = ceph::mono_clock;</span><br><span class="line">    <span class="keyword">using</span> <span class="type">scheduled_map_t</span> = std::multimap&lt;<span class="type">clock_t</span>::time_point, Context *&gt;;</span><br><span class="line">    <span class="type">scheduled_map_t</span> schedule;	<span class="comment">// 目标时间和定时任务执行函数Context</span></span><br><span class="line">    <span class="keyword">using</span> <span class="type">event_lookup_map_t</span> = std::map&lt;Context *, <span class="type">scheduled_map_t</span>::iterator&gt;;</span><br><span class="line">    <span class="type">event_lookup_map_t</span> events;	<span class="comment">// 定时任务&lt;--&gt;定时任务在schedule中的位置映射</span></span><br><span class="line">    <span class="type">bool</span> stopping;				<span class="comment">// 是否停止</span></span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 添加定时任务</span></span><br><span class="line">    <span class="function">Context *<span class="title">add_event_after</span><span class="params">(ceph::timespan duration, Context *callback)</span></span>;</span><br><span class="line">    <span class="function">Context *<span class="title">add_event_after</span><span class="params">(<span class="type">double</span> seconds, Context *callback)</span></span>;</span><br><span class="line">    <span class="function">Context *<span class="title">add_event_at</span><span class="params">(<span class="type">clock_t</span>::time_point when, Context *callback)</span></span>;</span><br><span class="line">    <span class="function">Context *<span class="title">add_event_at</span><span class="params">(ceph::real_clock::time_point when, Context *callback)</span></span>;</span><br><span class="line">    <span class="comment">// 取消定时任务</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">cancel_event</span><span class="params">(Context *callback)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cancel_all_events</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 定时任务执行</span></span><br><span class="line">    <span class="comment">/* 循环检查schedule中的任务是否到期，由于schedule中是按照时间升序排列的，因此第一任务没有到期就终止循环；</span></span><br><span class="line"><span class="comment">    如果第一任务到期，则调用callback执行，需要注意如果是非safe_callbacks，则需要先获取lock再执行callback函数。*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">timer_thread</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p><a href="https://item.jd.com/12072602.html">Ceph源码分析</a></p>
]]></content>
      <categories>
        <category>Ceph</category>
      </categories>
      <tags>
        <tag>Ceph</tag>
      </tags>
  </entry>
</search>
